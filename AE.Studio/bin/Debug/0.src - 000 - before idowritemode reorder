(@reset;    @<; @mode 254; @>; @hault; @<; @mode 255; @>;
//@dup;       @<; @osp++; @push 3; @mov; @osp--; @>;
//~~@dup;       @<; @mov -1; @>;
@dup;       @<; @mov -1; @>;
//@neg;       @<?; @dup; @osp--; @osp--; @push 0; @osp++; @sub; @>;
@neg;       @<; @dup; @mov 0 -4; @drop; @drop; @sub; @>;
@add;       @<; @neg; @sub; @>;
@inc;       @<; @sub -1; @>;
@dec;       @<; @sub +1; @>;
@sign;      @<; @jpos ^POS; @neg; @jpos ^NEG; @ret; @:POS; @ret +1; @:NEG; @ret -1; @>;
@compare;   @<; @sub; @sign; @>;
@swap_n;    @<; @dup; @dup; @sub -2; @mov; @dup; @mov 6; @mov 4; @drop; @neg; @sub 2; @mov; @drop; @drop; @drop; @mov -4; @drop; @drop; @>;
@swap;      @<; @swap_n 3; @drop; @>;

@get;       @<; @dup; @sub -2; @mov; @drop; @>;
//~~@set;       @<; @neg; @sub +2; @mov; @drop; @drop; @>;
@set;       @<; @neg; @sub +1; @mov; @drop; @drop; @>;
@true;      @<; @ret 1; @>;
@false;     @<; @ret 0; @>;
@not;       @<; @jpos ^1; @neg; @jpos ^1; @drop; @ret 1; @:1; @ret 0; @>;
@make12345; @<; @push N-111 N-2222 N-33333 N-444444 N-5555555; @>;
@goto;      @<; @dup; @set 1 3; @csp--; @jpos; @>;
//@is-zero?; @<; @not; @>;
@case;      @<; @get 3; @get 3; @sub; @not; @jpos ^Jumping; @drop;@drop;@drop; @ret; @:Jumping; @mov -3; @set 1 5; @drop; @drop; @csp--; @jpos; @>;
//@jump;      @<; @push 1; @swap; @csp--; @jpos; @>;
//@jif0;      @<; @swap; @dup; @push ^POS; @jpos; @neg; @push ^NEG; @jpos; @osp--; @osp--; @csp--; @jump; @:POS; @:NEG; @swap; @drop; @>;
//@jifeq;
//@<;
//	//@here;
//	@dup; @mov 5; @mov 5; @osp--; @compare; @push ^IfJumping; 
//	@jif0;
//	
//	@osp--;@osp--;@ret;
//	
//	@:IfJumping; @mov -4; @osp--;@osp--;@osp--; @csp--; @jump;
//@>;
//@jif1;      @<; @here; @swap; @dup; @push 1; @sub; @push ^IFJUMPING; @jif0; @osp--; @push -3; @mov; @osp--; @osp--; @ret; @:IFJUMPING; @osp--; @csp--; @jump; @>;
@equals?;   @<; @get 2; @get 2; @sub; @not; @set 3; @drop; @jpos ^True; @ret; @:True; @ret 1; @>;
@dignode;   @<; @unfold; @dec; @swap; @>;


@delete;    @<; @dup; @jpos ^OK; @error "WTF: non-positive offset specified"; @:OK; @dup;@dup; @<*; @sub -2; @mov; @neg; @sub 1; @mov; @neg; @sub 4; @*>; @drop; @drop; @drop; @drop; @>;
@insert;    @<; @get 2; @get 2; @<*; @push 7; @get 4; @get 3; @sub; @neg; @sub; @dup; @mov; @neg; @sub -1; @mov; @drop; @drop; @dec; @*>; @drop; @get 2; @neg; @sub 4; @mov; @drop;@drop;@drop;@>;

//@get; @<; @push 0; @push iA; @>;
//@get 5;
//@set 4;

@!program;
@<;
	@GetBaseGroupingBlock;
	//@here;
	@ProcessBlock;
	@here;
	
	@unfold-list;
	@get 4;
	@unfold-list;
	
	
	@here;
	
	@resolve-value;
	@drop;
	@here;
	//@make12345;
	@push 111 222 333;
	@push 2;
	@set-return-value;
	@here;

	@here;
@>;

//@CallFunction;
//@<;
//	
//@>;
@GetBaseGroupingBlock;
@<;
	@unfold-node 1; @drop;
	@unfold-node 1; @drop;
	@unfold-node 1; @drop;
	//@unfold; //@drop;
@>;
@ProcessBlock;
@<;
	//@here;
	@node-length; @jpos ^Children;
	@drop;@drop; @fold-list 0; @ret;
	
	@:Children;
		@dup;
		@mov "RETVALHERE" -4; @drop; @drop;
		@unfold-node 1;
		@<*;
			@dec;
			@get 2;
			@ProcessExpression;
			//@here;
			
			@get 2;
			@get 4; @sub -6; @set;
			//@drop;
			@mov -3;
			@drop;@drop;
			@get 2; @set 4; @set 2;
			
			@jpos ^NextExpression;
			@drop;
			@<*;
				//~~ removing queue;
				//@here;
				@dec; @mov -3; @drop; @drop;
			@*>;
			
						
			@:NextExpression;
				//@here;
		@*>;
		//@here;
		@drop;


//	@here;
//	@unfold-node 1;
//	
//	@dup; @jpos ^Children; //~~ empty block allowed, returns empty list;
//	@drop;
//	@fold-list; @ret;
//	
//	@:Children;
//	@<*;
//		@dec;
//		@get 2;
//		@ProcessExpression;
//		@set 3;
//	@*>;
//	@drop;
@>;
//@ProcessBlock;
//@<;
	//@here;
	//@node-length; @jpos ^Children;
	//@drop;@drop; @fold-list 0; @ret;
	
	//@:Children;
		//@dup;
		//@mov "RETVALHERE" -4; @drop; @drop;
		//@unfold-node 1;
		//@<*;
			//@dec;
			//@get 2;
			//@ProcessExpression;
			////@here;
			//@get 2; @sub -4;
			//@set;
			////@drop;
			//@mov -3;
			//@drop;@drop;
		//@*>;
		////@here;
		//@drop;
	
////	@here;
////	@unfold-node 1;
////	
////	@dup; @jpos ^Children; //~~ empty block allowed, returns empty list;
////	@drop;
////	@fold-list; @ret;
////	
////	@:Children;
////	@<*;
////		@dec;
////		@get 2;
////		@ProcessExpression;
////		@set 3;
////	@*>;
////	@drop;
//@>;
@ProcessExpression; //~~ [iExpNode, oExpList,oIsLast];
@<;
	//@here;
	@get-node-role;
		@case $.SemanticRole.ExpOneList    ^OneList;
		@case $.SemanticRole.ExpAssignment ^Assignment;
		@case $.SemanticRole.ExpCustom     ^Custom;
	@drop;
	@error "Not implemented";
	
	
	@:OneList;
		//@here;
		@ProcessExpression-OneList;
		@ret;
	@:Assignment;
		//@here;
		@ProcessExpression-Assignment;
		@here;
		@ret;
	@:Custom;
		@here;
		@ret;
@>;
@ProcessExpression-OneList;
@<;
	@unfold-node 1; @drop;
	@ProcessList +123456789; //~~ is writemode?;
	@true;
@>;
//@ProcessExpression-OneList;
//@<;
//	@here;
//	@unfold-node 1;
//	
//	@dup; @jpos ^Children; //~~ any expression returns list;
//	@drop;
//	@fold-list; @ret 0;
//	
//	
//	@:Children;
//	@<*;
//		@dec;
//		@get 2;
//		@here;
//		@ProcessList 0; //~~ is writemode?;
//		@here;
//		@set 3;
//		@drop;
//	@*>;
//	@drop;
//	@ret 1;
//@>;
@ProcessExpression-Assignment;
@<;
	@here;
	@unfold-node 1;
	
	@dup; @jpos ^Children; //~~ any expression returns list;
	@drop;
	@fold-list; @ret 0;
	
	
	@:Children;
	@<*;
		@dec;
		@get 2;
		@ProcessList 123456789;
		@set 3;
	@*>;
	@drop;
	@ret 1;
@>;
@ProcessList;
@<;
	//@here;
	//@drop;
	@get 2;
	@unfold-node 1;
	@dup;
	@<*;
		@push "------";
		@get 3; @get 3;
		@sub; @sub -5;
		@mov;
		@get 2;
		//@here;
		//@get 2;
		//@drop;
		//@here;
		@get 0 5; @sub -8; @mov; @drop;
		
		@here;
		@ProcessListItem;
		//@here;
		
		@set 3;
		@neg;
		@mov;
		@drop;
		@drop;
		
		@dec;
	@*>;
	//@here;
	@drop;
	@fold-list; //~~ expects [Count,Item1,Item2, .. ItemN];
	@mov -4; @drop; @drop; @drop;
@>;
//@ProcessList;
//@<;
//	//@here;
//	
//	
//	@unfold 1;
//	@<*;
//		//@stacksize; @sub 14; @<?; @here; @?>; @drop;
//		@dec;
//		@get 2;
//		@here;
//		@ProcessListItem;
//		@set 3;
//	@*>;
//	@drop;
//	
//	@here;
//	@fold-list; //~~ expects [Count,Item1,Item2, .. ItemN];
//@>;
@ProcessListItem; //~~ S0 = iIsWriteMode, S1 = Node;
@<;
	//@here;
	
	@get 2;
	//@drop;
	//~~ can return folded list;
	@unfold-node 1;
	
	@<*;
		//@here;
		@dup;
		@push 0;
		@get 2; @equals? 1;// @here;
		@<?;
			@here;
			@drop;
			@mov 7;
		@?>;
		@drop;
		
		
		@get 4;
		@here;
		@ProcessAtom;
		//@here;
		
		@delete 3;
		
		@dec;
	@*>;
	//@here;
	@drop;
	@set 3; @drop;
@>;
//~~@ProcessListItem;
//@<;
//	@drop;
//	//~~ can return folded list;
//	@unfold-node 1;
//	
//	@<*;
//		@get 2;
//		@ProcessAtom 0;
//		@dec;
//	@*>;
//	@drop;
//	
//@>;
@ProcessAtom;  //~~ S0 = iIsWriteMode, S1 = Atom(node);
@<;
	@here;
	@get 2; @jpos ^WriteMode; @drop;
	
	@:WriteMode;
		@bla;@bla;@bla;
	//@here;
	//@error "NI";
	//@drop;
	@is-node?;
	@<?;
		@drop;	
		//@here;
		//@push $.SyntaxNodeType.NumInt31;
		@get-node-type; //@dup; @sub 0; @here;
			@case $.SyntaxNodeType.NumInt32 ^NumInt32;
			@case $.SyntaxNodeType.String   ^NumInt32;
			//~~@case 19 ^LocalIdentifier;
			//@case LocalIdentifier ^LocalIdentifier;
			@case $.SyntaxNodeType.Identifier      ^Identifier;
			@case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
			
			@case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
			@case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
			
			@error "Unresolved";
		
		@:NumInt32;
			//@drop;	
			@get-node-value;
			
			//@here;
			@goto ^EOFirstNode;
			
		@:Identifier;
			//@here;
			//~~@push 0; @push 5; @mov; @drop;
			@get-node-value;
			@get-member;
			@dup;
			@set "------" 2;
			//@here;
			//~~@push -4; @mov; @drop; @drop; @swap;
			//@mov -4; @drop; //@drop;
			
			@goto ^EOFirstNode;
			@here;
			
		@:LocalIdentifier;
			//@drop;
			//@here;
			@get-node-value;
			@get-variable;
			@get-variable-value;
			@goto ^EOFirstNode;
//		Identifier,
//			Instruction,
//			InputIdentifier,
//			OutputIdentifier,
//			LocalIdentifier,
//			GlobalIdentifier,
//			FunctionIdentifier,
//			Word,
//
//			Type,
//			PackedTuple,
//		
		@:ArgumentBlock;
			@error "Using ArgumentBlock as a first item";
		@:GroupingBlock;
			//@here;
			@ProcessBlock;
			//@here;
			@goto ^EOFirstNode;
//			@here;
//			@Emulate_ProcessBlock;
//			@here;
//			
		@:EOFirstNode;
			//@here;
			@set 4;
			@drop;
			//@here;
		@true;
	@?>;
	@not;
	@<?;
		@drop;
		//@here;
		//@push $.AEDLObjectType.obj;
		
		@get-object-type; @equals? $.AEDLObjectType.Function;
		@<?;
			//~~ function;
			//@here;
			@drop;
		
			@get 6; @get-node-type; @equals? $.SyntaxNodeType.ArgumentBlock;
			@<?;
				@drop;
				//~~ is argument block;
				//@here;
				
				//~~ reserve stack slots for return value: [oX,oY,oZ,3];
				
//				
				//@here;
				@ProcessBlock;
				
				@get 2;
				//@dup; @sub -3; @get;
				
				//@here;
				@call-function;
//				
				@mov -7;
				@drop;
				@drop;
				@drop;
				@drop;
				@drop;
				
				//@mov -3;
				//@drop;@drop;
				//@dec;
//				@here;
//				@dup; @sub -3;
//				@dup; @delete;
//				@dup; @delete; @dup; @sub -1;
//				@delete;
//				@drop;
//				//@delete 3;
//				@here;
//				
				
//				@dup;
//				@neg; @sub 4; @mov;
//				
//				
				@true;
			@?>;
			@not;
			@<?;
				@drop;
				//~~ something else;
				@false;
			@?>;
			@drop;
			
			//@here;
			
			//@ProcessAtom-Function;
			
			@true;
		@?>;
		@not;
		@<?;
			@drop;
			//@here;
			
			//~~@push 0; @push 5; @mov; @drop;
			@get 6;
			@get-node-value;
			@get-member;
			
			
			//@here;
			@set 5; @drop; @drop;// @set 3;
			//@here;
			//~~@push -4; @mov; @drop; @drop; @swap;
			//@set 2; @swap;
			//@:EOMember;
			//	@here;
			//	@set 3;
			//@here;
			
			//@here;
			@false;
		@?>;
		@drop;
		@false;
	@?>;
	@drop;
	@ret;
	
	

@>;
@ProcessAtom-Function;
@<;
	//~~@push 0; @push 4; @mov; @drop; @push 0; @compare;
	@get 2; @compare 0;
	@<?;
		@drop;
	
		//~~ @push 0; @push 5; @mov; @drop;
		@get 3; @get-node-type; @equals? $.SyntaxNodeType.BLAADASF;
		@<?;
			@drop;
			
			
			@here;
			@true;
		@?>;
		@drop;
		@here;
		
		@ret;
	@?>;
	@drop;
@>;
@Emulate_ProcessBlock;
@<;
	@push "Hello, World!" 222 111 3;
@>;
@MyTestFunction;
@<;
	//@here;
	@unfold-list;
	@<*; @sub 1; @mov -3; @drop; @drop; @*>; @drop;
	
	
	@fold-list "YO-HO-HO!" 222 333 444 555 5;
@>;

);
//(_X,_Y,_Str 111,222,"Hello, World".ToString[12345]);
//(_X,_Y,_Str 111,222,"Hello, World");
//~~(111,"Hello, World",_MyObject.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.MemA.MemB.MemC.FuncA[1,(1 + gSomething)].FuncB[_MyObj]);
//("11111","22222","33333");
//(_MyObj.MemA.MemB.MemC.FuncA,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[].AAA.BBB.CCC,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[11111,22222,33333].AAA.BBB.CCC,44444,555555);
(
	//_Node.Children[1].Children[0]  _MyChild;
	
	//_Str "Hello, World!";
	///_X,_Y,_Str 42,12345,"Hello, World!";
	//111,222,_MyObj.MemA.MemB.MemC.FuncA[333,444,555];
	//42 + _MyObj.Age;
	_MyObj.MemA.MemB.MemC.FuncA["Hello, FuncA!"],11111,22222;
	//111,111111,111111111;
	//222,222222,222222222;
	//_MyObj.Age,333333,_MyObj.Name;
);
//(_MyObj.MemA.MemB.MemC,_MyObj.Name,_MyObj.Age,12345,"Hello, World!");
//(_MyObj.MemA.MemB.MemC.FuncA[111,222,"Hello, World!"].FuncB[_MyObj]);
//((111,222,"Hello, World!"));
//(i1 * 2);
//~~(2.718281828,"Hello, World!");
//(_X 111; _Y 222);
_X,_Y (123,iForm.Name,_MyObj.Name.Func[1,2,_Name.ToString[]],SomethingElse);





//@drop;
//	
//	@here;
//	@push 1;
//	@equals? 0;
//	@<1?;
//		@here;
//		@drop;
//		
//		@bla;@bla;@bla;@bla;
//		@bla;@bla;@bla;@bla;
//		@bla;@bla;@bla;@bla;
//		
//		@true;
//	@1?>;
//	
//	"
//		get-type equals[0]
//		<1
//			bla bla
//			bla bla
//			bla bla
//		1>
//		<0
//			bla bla
//			bla bla
//			bla bla
//		0>
//	
//	";
//	
//	@not;
//	@<?;
//		@drop;
//		
//		@bla;@bla;@bla;@bla;
//		@bla;@bla;@bla;@bla;
//		@bla;@bla;@bla;@bla;
//		
//		@false;
//	@?>;
//	@drop;
//	
//	@here;
//	
////	@make12345;
////	@push ^TEST;
////	//@xmov;
////	@here;
////	@ret 3; //~~ get address at S3 and return, replacing S3 with zero?;
////
////	@:TEST;
////	






















































