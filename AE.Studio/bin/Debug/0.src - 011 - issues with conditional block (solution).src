(
*drop1 {drop};
*drop2 {drop;drop;};
*drop3 {drop;drop;drop;};
*drop4 {drop;drop;drop;drop;};
*drop5 {set_SP (sub get_SP,-5)};
*drop6 {set_SP (sub get_SP,-6)};
*drop7 {set_SP (sub get_SP,-7)};
*drop8 {set_SP (sub get_SP,-8)};
*drop9 {set_SP (sub get_SP,-9)};

//*!0 {sub get_SP,+1};
*!1 {get_SP};
*!2 {sub get_SP,-1};
*!3 {sub get_SP,-2};
*!4 {sub get_SP,-3};
*!5 {sub get_SP,-4};
*!6 {sub get_SP,-5};

*neg {dup; set !3 0; sub};
*abs {dup; jpos ^RET; drop; neg; :RET;};
*jump {dup; set !3 1; csp++; jpos};
*loop {dup};

*inc {sub -1};
*dec {sub +1};

**inc {dup; dup; get; inc; set !3; set};
**dec {dup; dup; get; dec; set !3; set};

**sub    {!!!;};
**equals {!!!;};
**less?  {get; !3; get; sub; jpos ^TRUE; set !3 0; drop; ret; :TRUE; set !2 1;};

test (_L1,_L2)
{
	set _L1 4;
	set _L2 5;
	
	*less? _L1,_L2;
	!!!;
	
};
!program (oError)
{
	//test;
	//!!!;
	

	+GetBaseGroupingBlock;
	+ProcessBlock;
	
	
	
	
	reset;
};

old_program_X (i1,i2,i3,o1,o2)
{
	!!!;
	111,1111,11111,111111,1111111;
	xget 2;
	@GetBaseGroupingBlock;
	//here;
	ProcessBlock;
	xmovup;
	
	here;
	unfold-list;
	drop;
	unfold-list;
	here;
};

*+GetBaseGroupingBlock
{
	get !3;
	get-node-child 0;
	get-node-child 0;
	get-node-child 0;
	set !4;
	drop2;
};
+ProcessBlock (iNode,oList,_RetVal,_ChildCount,cChildI)
{
	get iNode;
	
	//!!!;
	//~~old_program_X (111,222,333);
	//here;
	//!!!;
	set _RetVal "-RETVAL-";
	set oList (create-list (get-node-children-count));
	
	
	
	//!!!;
	
	//get iNode;
	set _ChildCount get-node-children-count;
	set cChildI 0;
	//!!!;
	
//	^NextChild;
//		get-node-child cChildI;
//		
//		jpos cChildI,^NextChild;
////		
//		
	//!!!;
	
	loop;/// (get cChildI);
	{
		drop;
		//!!!;
		
		
		
		!!!;
		*less? (*inc dup cChildI),_ChildCount;
		//*less? (*inc dup cChildI),_ChildCount;
		
	};
	!!!;
	get-node-child;
	{};
	:Children;
		//dup;
		push "-- RETVAL --";
		//xmov "RETVALHERE" -4; drop; drop;
		//here;
		xget 2;
		unfold-node 1;
		<*;
			//here;
			//dec;
			xget 2;
			//here;
			ProcessExpression;
			//here;
			
			//xget 2;
			//here;
			//~~ xsetting return value;
			xget 4; sub -5; xset;
			
			//drop;
			//~~xget 3; xset 5;
			xmovup;//~~xset 2;
			
			//drop;drop;
			//xget 2; xset 4; xset 2;
			//dup;
			
			jpos ^NextExpression; drop;drop;
			<*;
				//~~ rexmoving queue;
				dec; xmovup;
			*>;
			drop; ret;
			
			:NextExpression;
				xmovup;
				dec;
		*>;
		//here;
		drop;


//	here;
//	x-unfold-node 1;
//	
//	dup; jpos ^Children; //~~ empty block allowed, returns empty list;
//	drop;
//	fold-list; ret;
//	
//	:Children;
//	<*;
//		dec;
//		xget 2;
//		ProcessExpression;
//		xset 3;
//	*>;
//	drop;
	:RET;
		!!!;
		bla;bla;bla;
};
ProcessExpression_X (iExpNode,oList,oDoProceedNext)//~~ S0=iExpNode -> S0=oExpList,S1=oDoProceedNext;
{
	get-node-role;
		case $.SemanticRole.ExpOneList    ^OneList;
		case $.SemanticRole.ExpAssignment ^Assignment;
		case $.SemanticRole.ExpCustom     ^Custom;
		case $.SemanticRole.Unknown       ^Assignment;
		error "Not implemented";
	drop;
	
	:OneList;
		//here;
		ProcessExpression-OneList;
		ret;
	:Assignment;
		//here;
		ProcessExpression-Assignment;
		//here;
		ret;
	:Custom;
		here;
		ret;
};
ProcessExpression-OneList (iExpNode,oList)
{
	//here;
	push "NOTHINGTOWRITE";
	push 0; //~~ is write mode?;
	xget 3;
	unfE 1; drop;
	ProcessList;
	//here;
	
	xmovup;
	
	xset 1 4; //~~ do proceed next expression;
	xmovup;
	//true;
	
	
	//here;
	//drop;
	//push 1;
	//fold-list 111 222 333 3;
};
ProcessExpression-Assignment_X (iExpNode,oList)
{
	//here;
	dup;
	unfE 1;
	
	drop;
	//here;
	//~~ processing source list;
	push "NOTHINGTOWRITE";
	push 0; xget 4; ProcessList; xmovup; xmovup; xmovup; //here;
	unfold-list;
	
		
	dup; sub -2; xget;
	unfL 1;
	
	//~~ determining the type of assignment: list-to-list, folding and unfolding a tuple;
	dup; sub -2; xget;
	xmov 0 4; drop;
	//here;
	//~~ S0 and S1 are the list lengths;
	sub;
	not; jpos ^ListToList; error "Tuples are not implemented yet";
	
	
	:ListToList;
		dup;
		//here;
		<*;
			//here;
			//~~ computing zero-based offxset to grow;
			push 3; xget 2; sub; //neg;
			
			//here;
			//~~ list item to read;
			xget 3; dup; neg; sub; sub -4; //~~ count+count+3;
			xget 2; neg; sub; dup; //~~ adding zero-based offxset;
			xmov; drop;
			
			
			push 1; //~~ the 'write-mode' argument;
			
			//here;
			//~~ list item to write
			xget 5; xget 5; sub; sub -6; xget;
			
			//here;
			ProcessListItem;
			//here;
			
			drop;drop;drop;drop;drop;
			
//			get-node-value;// xmovup;
//			get-variable;
//			
//			here;
//			set-variable;
//			
//			
			dec;
		*>;
	
		//~~dup; sub -2; xget;
		//here;
		drop;
		<*; dec; xmovup; *>; drop;
		//here;
		fold-list;
		xset 1 4;
		xmovup;
		
		//here;
		//<*; dec; xmovup; *>; drop;
		//drop;
		//drop;
};
//~~ProcessList_X (iNode,iIsWriteMode,rValueToWrite,oList);
ProcessList_X (rValueToWrite,iNode,iIsWriteMode,oList)
//~~ S0=iNode,S1=iIsWriteMode,S2=VALUETOWRITE_NOT_USED -> S0=oList;
{
	//drop;//drop;
//	fold-list 1111 2222 3333 3;
//	ret;

	//here;
	dup; unfL 1;
	dup;
	<*;
		//here;
		push "------";
		
		//here;
		//~~ node;
		xget 3; xget 3; sub; sub -5; xmov;// drop;
		//here;
		//~~ optional value to write;
		//here;
		xget 4; sub -9; dup; xmov;
		//xget 10;
		//dup; sub -5; xget;
		
		//here;
		//~~ write-mode flag;
		dup; xmov; drop;//xget 10;
		//xget 2; sub -5; xget;
		
		//~~<?; here; ?>;
		
		xget 4;
		//here;
		ProcessListItem;
		//here;
		
		xmov -7;  drop; drop; drop; drop; drop;
		neg;
		xmov;     drop; drop;
		
		dec;
		//here;
	*>;
	//here;
	drop;
	fold-list; //~~ expects [Count,Item1,Item2, .. ItemN];
	//xmov -4; drop; drop; drop;
};
ProcessListItem_X (iNode,iIsWriteMode,iValueToWrite,oList)
 //~~ S0=iNode,S1=iIsWriteMode,S2=iValueToWrite(opt); -> S0=oList(opt);
{
	//xget 2; <?; here; ?>; drop;
	
//	fold-list 111 2222 3333 3;
//	
//	ret;
	
	//here;
	//xget 2;
	//drop;
	//~~ can return folded list;
	push "-- MEMBERBASE --";
	xget 2;
	
	unfI 1;//here;
	<*;
		//here;
		dup;
		//~~ if is last atom in list-item (uses write-mode flag);
		equals? 1; <?; xmov 7; drop; ?>;
		
		//drop; 0 - [iIsWriteMode = 0];
		//dup;
		//~~ value-to-write;
		xget 2; sub -6; xget;
		//~~  write-mode flag;
		xget 2;
		//~~ member base;
		xget 4; sub -5; xget;
		
		//here;
		///xget 4; <?; here; ?>; drop;
		xget 6;
		//here;
		ProcessAtom;
		
		//here;
		//xget 4; <?; here; ?>; drop;
		//here;
		
		xget 7; sub -8; xset;
		drop; drop; drop; drop; drop;
		xmovup;
		dec;
	*>;
	//here;
	drop;
	//xset 3; drop;
};
ProcessAtom_X (iNode,iMemberBase,iIsWriteMode,iValueToWrite,oValue)
//~~ S0=iNode,S1=iMemberBase,S2=iIsWriteMode,S3=iValueToWrite(opt); -> S3=oValue(opt)
{
	//~~xget 3; <?; here; ?>; drop;
	
	xget 3; jpos ^WriteMode; drop;
		ProcessAtom-Read;
		ret;
	:WriteMode;
		ProcessAtom-Write;
		ret;
//	
//	//here;
//	//error "NI";
//	//drop;
//	dup;
//	is-node?;
//	<?;
//		drop;	
//		//here;
//		//push $.SyntaxNodeType.NumInt31;
//		get-node-type; //dup; sub 0; here;
//			case $.SyntaxNodeType.NumInt32 ^NumInt32;
//			case $.SyntaxNodeType.String   ^NumInt32;
//			//~~case 19 ^LocalIdentifier;
//			//case LocalIdentifier ^LocalIdentifier;
//			case $.SyntaxNodeType.Identifier      ^Identifier;
//			case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
//			
//			case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
//			case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
//			
//			error "Unresolved";
//		
//		:NumInt32;
//			//here;
//			//drop;	
//			get-node-value;
//			
//			//here;
//			goto ^EONode;
//			
//		:Identifier;
//			//here;
//			//~~push 0; push 5; xmov; drop;
//			xmov 0 5; dup; xmov; drop;
//			//here;
//			get-node-value;
//			get-member;
//			xmovup;
//			
//			//dup;
//			//xset "------" 2;
//			//here;
//			//~~push -4; xmov; drop; drop; swap;
//			//xmov -4; drop; //drop;
//			
//			goto ^EONode;
//			//here;
//			
//		:LocalIdentifier;
//			//drop;
//			//here;
//			
//			get-node-value;// xmovup;
//			get-variable;
//			get-variable-value;
//			goto ^EONode;
////		Identifier,
////			Instruction,
////			InputIdentifier,
////			OutputIdentifier,
////			LocalIdentifier,
////			GlobalIdentifier,
////			FunctionIdentifier,
////			Word,
////
////			Type,
////			PackedTuple,
////		
//		:ArgumentBlock;
//			//here;
//			//error "Using ArgumentBlock as a first item";
//			ProcessBlock;
//			xget 4;
//			call-function;
//			//here;
//			xmov -4; drop; drop; drop;
//			
//			goto ^EONode;
//			
//		:GroupingBlock;
//			//here;
//			ProcessBlock;
//			xmovup;
//			//here;
//			goto ^EONode;
////			here;
////			Emulate_ProcessBlock;
////			here;
////			
//		:EONode;
//			//here;
//			//xset 4;
//			//drop;
//			//here;
//		//true;
//	?>;
//	ret;
//	
//	:WriteMode;
//		here;
//		
//		get-node-type;
//		case $.SyntaxNodeType.GroupingBlock ^Grou
//		
//		xget 4;
//		xget 2;
//		get-node-value;
//		set-variable;
//		//get-object-type;
//		drop;
};
ProcessAtom-Read_X (iNode)
{
	//here;
	
	dup;
	is-node?;
	<?;
		drop;	
		//here;
		//push $.SyntaxNodeType.NumInt31;
		get-node-type; //dup; sub 0; here;
			case $.SyntaxNodeType.NumInt32 ^NumInt32;
			case $.SyntaxNodeType.String   ^NumInt32;
			//~~case 19 ^LocalIdentifier;
			//case LocalIdentifier ^LocalIdentifier;
			case $.SyntaxNodeType.Identifier      ^Identifier;
			case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
			
			case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
			case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
			
			error "Unresolved";
		
		:NumInt32;
			//here;
			//drop;	
			get-node-value;
			
			//here;
			ret;
			
		:Identifier;
			//here;
			//~~push 0; push 5; xmov; drop;
			xmov 0 5; dup; xmov; drop;
			//here;
			get-node-value;
			get-member;
			xmovup;
			
			//dup;
			//xset "------" 2;
			//here;
			//~~push -4; xmov; drop; drop; swap;
			//xmov -4; drop; //drop;
			
			ret;
			//here;
			
		:LocalIdentifier;
			//drop;
			//here;
			
			get-node-value;// xmovup;
			get-variable;
			get-variable-value;
			ret;
//		Identifier,
//			Instruction,
//			InputIdentifier,
//			OutputIdentifier,
//			LocalIdentifier,
//			GlobalIdentifier,
//			FunctionIdentifier,
//			Word,
//
//			Type,
//			PackedTuple,
//		
		:ArgumentBlock;
			//here;
			//error "Using ArgumentBlock as a first item";
			ProcessBlock;
			xget 4;
			call-function;
			//here;
			xmov -4; drop; drop; drop;
			
			ret;
			
		:GroupingBlock;
			//here;
			ProcessBlock;
			xmovup;
			//here;
			ret;
//			here;
//			Emulate_ProcessBlock;
//			here;
//			
		//:EONode;
			//here;
			//xset 4;
			//drop;
			//here;
		//true;
	?>;
	error "ND";
};
ProcessAtom-Write_X (iNode)
{
	//here;
	dup;
	get-node-type;
		case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
		case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
		case $.SyntaxNodeType.Identifier      ^Identifier;
		case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
		
		error "NI";
	
	:LocalIdentifier;
		//here;
		xget 5;
		xget 2;
		get-node-value;
		set-variable;
		//get-object-type;
		drop;
		xmovup;
		ret;
		
	:Identifier;
		//here;
		//~~push 0; push 5; xmov; drop;
		xget 5;
		xget 4;
		xget 3;
		
		//xmov 0 5; dup; xmov; drop;
		//here;
		get-node-value;
		set-member;
		//here;
		xmovup;
		
		//dup;
		//xset "------" 2;
		//here;
		//~~push -4; xmov; drop; drop; swap;
		//xmov -4; drop; //drop;
		
		ret;
	:ArgumentBlock;
		//here;
		
		ProcessBlock;
		xget 6;xget 6;xget 3;xget 7;
		
		call-function;
		//here;
		xmov -7; drop;drop;drop;drop;drop;drop;
			
		ret;
	:GroupingBlock;
		//here;
		//~~ check expression count: allowed only 1 expression in block;
		node-length; equals? 1; not;
		<?;
			drop;
			error "Only 1 expression allowed";
		?>;
		drop;
		
		//~~ unflolding;
		dup; unfGB 1; drop;
		//here;
		
		//~~ check list count: allowed only 1 list in the only expression;
		node-length; equals? 1; not;
		<?;
			drop;
			error "Only 1 list allowed";
		?>;
		drop;
		
		//here;
		//~~ processing list;
		unfE 1; drop; unfL 1;
		<*;
			here;
		*>;
		
		here;
		ret;
};

//ProcessAtom-Function
//{
//	here;
//	//~~push 0; push 4; xmov; drop; push 0; compare;
//	xget 2; compare 0;
//	<?;
//		drop;
//	
//		//~~ push 0; push 5; xmov; drop;
//		xget 3; get-node-type; equals? $.SyntaxNodeType.BLAADASF;
//		<?;
//			drop;
//			
//			
//			here;
//			true;
//		?>;
//		drop;
//		here;
//		
//		ret;
//	?>;
//	drop;
//};
Emulate_ProcessBlock_X (iNode,oStrHW,oNum1,oNum2,oResCount)
{
	push "Hello, World!" 222 111 3;
};
MyTestFunction (iList,oList)
{
	//here;
	dup;
	unfold-list;
	<*; sub 1; xmov -3; drop; drop; *>; drop;
	
	
	fold-list "YO-HO-HO!" 222 333 444 555 5;
};

);
//(_X,_Y,_Str 111,222,"Hello, World".ToString[12345]);
//(_X,_Y,_Str 111,222,"Hello, World");
//~~(111,"Hello, World",_MyObject.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.MemA.MemB.MemC.FuncA[1,(1 + gSomething)].FuncB[_MyObj]);
//("11111","22222","33333");
//(_MyObj.MemA.MemB.MemC.FuncA,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[].AAA.BBB.CCC,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[11111,22222,33333].AAA.BBB.CCC,44444,555555);
(
	//_Node.Children[1].Children[0]  _MyChild;
	
	//_Str,_X,_Y   "Hello, World!",_MyObj.Age,_MyNum;
	////_Str,_X,_Y   "Hello, World!",_MyObj.Age,_MyNum;
	////~~_Str,_X,_Y,_Z _MyNum;
	//_X,_Y,_Str 42,12345,"Hello, World!";
	//(123,456) 123456;
	//(111,222) (333,444);
	_TEST                _MyObj.MemA.MemB.MemC.FuncA[333,444,555];
	
	_MyObj.Items[12345]  "First item";
	_X,_Y                _MyObj.Age,42;
	_X,_Y                _Y,_X;
		
	_Z           56;
	_MyObj.Age   _Z;
	_MyObj.Age;
	
	_Name1       _MyObj.MemA.MemB.MemC;
	_MyObj.MemA  2;
	_Name2       _MyObj.Name;
	
	_MyObj;
	

	
	//''

//	_List (123,456);
	
//	_X          11111;
//	_X,_Y       11111,22222;
	//_X,_Y,_Str  11111,22222,"Hello";
//	
//	_PosXY,(_W,_H) (111,222),(333,444);
//	
//	
//	_TEST _MyObj.MemA.MemB.MemC.FuncA[333,444,555];
	//42 + _MyObj.Age;
	//_MyObj.MemA.MemB.MemC.FuncA[11111,22222,"Hello, FuncA!"],11111,22222;
	//_MyObj.MemA.MemB.MemC.FuncA["Inputs1"] "Inputs2";
	//88,88,88,88,88,88,88,88,88,88,88;
	//55555555;
	//66666666;
	//77777777;
	//111,111111,111111111;
	//222,222222,222222222;
	//_MyObj.Age,333333,_MyObj.Name;
);
//(_MyObj.MemA.MemB.MemC,_MyObj.Name,_MyObj.Age,12345,"Hello, World!");
//(_MyObj.MemA.MemB.MemC.FuncA[111,222,"Hello, World!"].FuncB[_MyObj]);
//((111,222,"Hello, World!"));
//(i1 * 2);
//~~(2.718281828,"Hello, World!");
//(_X 111; _Y 222);
_X,_Y (123,iForm.Name,_MyObj.Name.Func[1,2,_Name.ToString[]],SomethingElse);


//RealNumber {Value;
//_MyRealNumber RealNumber[];

//_StringValue  $.Value.$str.Substring[0,3];
//_MyRealNumber._StringValue;

//Expression -> List -> ListItem -> Atom(inc. Block) -> Expression;
//";"          " "     ","         "."      "[,],(,),{,}"     



	get (sub #EAX -3);

	mov EAX,ST0;
	mov eax,st0;
	mov eax,O[ebp * 2 + 4];

	mov EAX,ST0;
	mov R0,ST0;
	mov r0,st0;


	mov #EAX,#ST0;
	mov #eax,#st0;
	mov #eax,O[#ebp * 2 + 4];

	mov #EAX,#ST0;
	mov #R0,#ST0;
	

	mov @EAX,@ST0;
	mov @eax,@st0;
	mov @eax,O[@ebp * 2 + 4];

	mov @EAX,@ST0;
	mov @R0,@ST0;


	mov %EAX,%ST0;
	mov %eax,%st0;
	mov %eax,O[%ebp * 2 + 4];

	mov %EAX,%ST0;
	mov %R0,%ST0;


	mov &EAX,&ST0;
	mov &eax,&st0;
	mov &eax,O[&ebp * 2 + 4];

	mov &EAX,&ST0;
	mov &R0,&ST0;


	mov *EAX,*ST0;
	mov *eax,*st0;
	mov *eax,O[*ebp * 2 + 4];

	mov *EAX,*ST0;
	mov *R0,*ST0;

	

	set oDest;

	get @IP;
	get iOffs;
	sub;
	get;
	set oDest;


a1; aName;
b1; bName;
c1; cName;
d1; dName;
e1; eName;
f1; fName;
g1; gName;
h1; hName;
i1; iName;
j1; jName;
k1; kName;
l1; lName;
m1; mName;
n1; nName;
o1; oName;
p1; pName;
q1; qName;
r1; rName;
s1; sName;
t1; tName;
u1; uName;
v1; vName;
w1; wName;
x1; xName;
y1; yName;
z1; zName;

!1; !Name;
@1; @Name;
#1; #Name;
$1; $Name;
%1; %Name;
^1; ^Name;
&1; &Name;
*1; *Name;
'1; 'Name;
:1; :Name;
/1; /Name;
|1; |Name;
=1; =Name;
+1; +Name;
-1; -Name;
_1; _Name;
\1; \Name;
`1; `Name;
<1; <Name;
>1; >Name;
?1; ?Name;


*basic_opcodes
{
	"
		[Opc. Im7.]
		[Opc. ....][Im8.....]
		[Opc. ....][Im16.............]
		[Opc. ....][Im32.............................]
		[Opc. ....][Im64.............................................................]
	";

	0xxxxxxx; //~~ 7bit immed;
	1xxxxxxx; //~~ ;

	00000000; //~~ breakpoint;
	1xxxxxxx; //~~ push immediate 7-bit (signed?);
	01000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;



	0000  //~~basic internal opcodes;
	0001 ??
	0010 push
	0011 drop (get_SP+push+sub+set_SP)
	0100 get
	0101 set
	0110 sub
	0111 jpos

	1000 //~~ extended internal opcodes;
	1001 get_SP ??? registers will be mapped to memory! need revise address space/
	1010 set_SP
	1011 get_FP
	1100 set_FP
	1101 get_IP
	1110 set_IP
	1111 //~~ extended syllable (extended to byte);

	1111 0000;
	
	push;
	drop;
	get;
	set;
	sub;
	jpos;
	(closer);
	EXT++;


	
	nop;
	ret;

	!!!;
	call;//~~ ???;
	mode,error; //~~???;
	
	opener,closer;

};