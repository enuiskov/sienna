 {};
 
 
 //fact, it is possible to define a complete system using only one combinator.
 //An example is Chris Barker's iota combinator, which can be expressed in
 //terms of S and K as follows:
//ιx = xSK
//It is possible to reconstruct S, K, and I from the iota combinator. Applying
//ι to itself gives ιι = ιSK = SSKK = SK(KK) which is functionally equivalent
//to I. K can be constructed by applying ι twice to I (which is equivalent
//to application of ι to itself):
//ι(ι(ιι)) = ι(ιI) yields ι(ISK) = ι(SK) = SKSK = K (see Example computation).
//Applying ι one more time gives ι(ι(ι(ιι))) = ιK = KSK = S.


//_XY {_X._Y};
//AAA.BBB.CCC.DDD.EEE.FFF;

//Kxy=x

//Аху = x + y


//_Kxy {i1,i2,o1; o1 i1; o1};
//_Kxy {i1,i2,o1; i1};
//_Kxy {i1};
//WTF
//_S   {};

////x.y.K -> x.K   //~~ x;
////z.y.x.S //~~ (z.y).(z.x) ;

//S.K.K   //~~ I;

//42.I = 42;
////42.I = 42.S.K.K; //~~;
//42.I = 42.(S.K.K); //~~;

//1.2.K   -> 1;
//1.2.3.S -> (3.2).(3.1);

//SSK;
////SxyzKK

//1.(S.K.K)
//-> [SxyzKK -> Kx(Kx) -> ]
//-> 1.(1.K).K ->






////42.(S.K.K) -> 42.K.(42.K) ->  -> 42
//42.(S.K.K) -> 42.(42.K).K -> 42

//((S K K) x) -> (S K K x) -> (K x (K x)) = x



//Sxyz = xz(yz)  (распределитель)
//K x y = x {\displaystyle Kxy=x} Kxy = x (вычеркиватель)


_X 1;
_X (1,2,3);


_MyObj ($.Name,$.Value "Vasya",3.1415);

iOperation ($.Name,$.Value);

_MyObj.iOperation.1.$str.(0,1,2,3); //~~ "3.14";



_X,_Y.Values (1,2,3),("Hello","World!");


{;;      _X,_Y.Name,_Array.[iIndex].Value       (1,2,3),4,5,6;     ;;}

'iName.MemberName.[];
'X.Name,'MyRect.Width;



gMyFunc[1,2,3];
gMyFunc.(1,2,3);
gMyFunc._List;
gMyFunc.Member;

gMyFunc {function body};
gMyFunc.DEF.(function body);
gMyFunc $.(i1,i2,o1; bla bla bla; 42);
gMyFunc $.(i1.i32,i2.i32,o1.i32; bla bla bla; 42);

gMyFunc $'(i1'$i32,i2'$i32,o1'$i32; bla bla bla; 42);
gMyFunc $.(i1.$i32,i2.$i32,o1.$i32; bla bla bla; 42);
gMyFunc $.(i1.$i32,i2.$i32,o1.$i32).(bla bla bla; 42);

gMyFunc $.(i1.$i32,i2.$i32,o1.$i32).
(
	bla bla bla;
	bla bla bla;
	bla bla bla;

	42;
);
+ $.(i1.$i32,i2.$i32,o1.$i32).(Math.Add.(i1,i2).$i32);
+ {i1.$i32,i2.$i32,o1.$i32; Math.Add[i1,i2].$i32};

+ [i1.$i32,i2.$i32,o1.$i32; Math.Add.[i1,i2].$i32];
Math.Add.[_X,_Y].$f32;

+ [Math.Add.[i1.$i32,i2.$i32]];
+ [Math.Add.[i1,i2]];
+ {Math.Add.(i1,i2)};


+ [Math'Add'[i1'$i32,i2'$i32]];
+ [Math'Add'[i1,i2]];
+ {Math'Add'(i1,i2)};



( _X 1; _Y 2;);
@bla;       @<; @>;

 
@reset;     @<!; @push 254; @mode; @>;
@halt;      @<!; @push 255; @mode; @>;
@drop;      @<?; @push 1; @remove; @push 0; @remove; @>;
//@inc;     @<; @push 1; @add; @>;
@add;       @<!; @push 3; @over; @over; @remove; @remove; @drop;	@push 0; @swap;	@sub;	@sub;	@swap;@>;
@inc;       @<!; @swap; @push -1; @sub; @swap; @>;
@dec;       @<!; @swap; @push +1; @sub; @swap; @>;
@neg;       @<!; @push 0; @push 3; @over; @remove; @drop; @sub; @swap; @>;

@swap;      @<!; @push 3; @over; @remove; @drop; @push 2; @over; @remove; @drop; @>;
@dup;       @<!; @push 2; @over; @over; @remove; @drop; @>;
@jump;      @<!; @drop; @push 1; @swap; @jpos; @>;
@ret;       @<!; @drop; @jump; @>;
//@call;      @<!; @drop; @jump; @>;
@compare;   @<!; @push 3; @over; @over; @remove; @remove; @drop;	@sub;	 @^COMPARE_BPos; @jpos;	@push 0; @swap; @sub;	 @^COMPARE_BNeg; @jpos;	@swap; @ret;		@:COMPARE_BPos;		@push +1; @swap; @ret;	@:COMPARE_BNeg;		@push -1; @swap; @ret;@>;
@make123;   @<!; @push -1;@push -22;@push -333;@push -4444;@push -55555; @push -666666; @push -7777777; @push -88888888; @push -999999999; @push 10; @over; @remove; @drop; @>;


@start;

@push 0;
@:C1;
	@push -1;
	@sub;
	@>C1;

@here;
@push 3;
@push 10;
@swap;
@here;
@sub;
@here;

@drop;
@here;



@rotate;
@<!;
	@swap;
	@dup;
	//@here;
	@^ROTATE_POS; @jpos;
	@:ROTATE_NEG;
		@drop;
		@here;
//		@push 3; @over; @drop;
		@push 2; @sub;//~~ @neg;
		@here;
		@push 3; @over; @drop;
		@swap;

		@over; @remove;
		



	@:ROTATE_POS;
		@push -2; @sub; @over; @remove; @drop;
	
	@swap;
	@ret;
@>;
@sub_n;
@<!;
//	@here;
//	@push 3; @over; @over; @remove; @remove; @drop;
//	
//	@push 3; @over;
//	@swap;
//	@push 123; @sub;
//	@swap;
//	@neg; @over;

	//@push 3; @over; @over; @remove; @remove; @drop;
	//@push -2; @sub; 
	
	//@over;
	//@push 3; @over; @over; @remove; @remove; @drop;
	//@swap;
	//@sub;
	//@swap;
	//@here;
@>;

@start;
@drop;
@make123;
//@here;
@push -5;
@:RotCyc;
	@rotate;
	@>RotCyc;
///@push -3; @rotate; @bla;@bla;@bla;
@reset;

@push 123; @push 3; @sub_n;

@here;


@push 123; @push 3; @sub_n;



@reset;


<,>,(push 12345),mode,copy,ins,del,sub,jpos,call;
<,>,(push 12345),drop,mode,copy,sub,jpos,call;
<,>,(push 12345),mode,mov,sub,jpos,call;

@<;@>;
@push;	//~~ push byte, word, double word etc;
@mode;	//~~ set intepreting mode with S0, drop S0;
@mov;		//~~ move something and somewhere;
			//~~ S0 = 0 -> drop S0,S1;
			//~~ S0 > 0 -> mov S1 to S[|S0|] index, drop S0?; 
			//~~ S0 < 0 -> mov from S[|S0|] to S1, drop S0?;
@sub;		//~~ S1 = S1 - S0, drop S0;
@jpos;	//~~ make jump to address S0 if (S1 > 0), drop: S0,(S1 if jump has occured);
@call;	//~~ go to S0 address, replacing S0 with an address of executed 'call' instruction;

111
2222
33333
444444
5555555
3
over








//@sub3; @<; @push 3; @sub_n; @>;

//~~@cif1;
//@<;
	////@here;
	
	//@push 3; @over; @remove; @over; @remove; @drop;

	//@swap;@drop;
////	@here;
	//@call;
	//@here;
	//@bla;@bla;@bla;@bla;@bla;
	//@bla;@bla;@bla;@bla;@bla;
	//@bla;@bla;@bla;@bla;@bla;

//@>;


//@here;

@push 1;
	@^FuncA; @cif1;

//@bla;@bla;@bla;

//@:_FuncA;
//	@^FuncA; @call;

@reset;

//~~@^FuncA; @call;

//@push "FuncA complete!";
//@push 0;
//@cycle;
@push 0;
@:CycleA;
	@inc;
	@>CycleA;
@reset;



@:FuncA;
	@push "FuncA executing...";
	@push 111;@push 111;@push 111;@push 111;@push 111;

	@push 8; @over; @over; @remove; @remove; @drop;

	@ret;
	





@push 22223;
@push 22222;

//@here;
//@sub;
@compare;
@here;
	@^B+1; @jp;
	@^B-1; @jn;
	@^B0;  @jz;
@drop;
@^B0; @jump;

///@here;

//@push 0;
	//@^MyFuncIf1; @cif1;
	//@^MyFuncIf0; @cif0;
	
	//@bla;@bla;@bla;@bla;
//@>END;

@push 0;
	@^B0; @jif0;
	@^B1; @jif1;
@drop;
@bla;@bla;
@>END;


@:MyFuncIf1;
	@push 11111;@push 22222;@push 33333;@push 44444;@push 55555;
	@ret;
@:MyFuncIf0;
	@push -11111;@push -22222;@push -33333;@push -44444;@push -55555;
	@ret;


@:B+1;
	@push +1;@push +1;@push +1;@push +1;@push +1;
	@>END;
@:B-1;
	@push -1;@push -1;@push -1;@push -1;@push -1;
	@>END;
@:B0;
	@push 0;@push 0;@push 0;@push 0;@push 0;
	@>END;
@:END;
@here;
@reset;



@cif1;
	@<w;
		//~~ S0 = label, S1 = condition(1 or 0)?;
		@push 2; @over;
		@push 1; @compare;
		@here;
		@^CIF1_L1; @jif1;
		@^CIF1_L0; @jif0;
		
		@:CIF1_L1;
			@push 2; @remove; @drop;
			@call;
			@push 1; //~~ to skip next branching if 0 or something;
			@>CIF1_END;
		@:CIF1_L0;
			@bla;@bla;@bla;
		@:CIF1_END;
	@w>;
@cif0;
	@<w;
		@here;
		@push 2; @over;
		@push 1; @compare;
		@push 3; @remove; @drop;
			
			
		@>CIF0_END;
		
		
		
		
			@^CIF0_L1; @jif1;
			@^CIF0_L0; @jif0;
			
		@:CIF0_L1;
			@push 2; @remove; @drop;
			@call;
			@push 0; //~~ to skip next branching if 1 or something;
			@>CIF1_END;
		@:CIF0_L0;
		@:CIF0_END;
	@w>;


@:MyFunc001;
@<;
	@push "MyFunc has been executed";
	@bla;@bla;@bla;
	
	@push 2; @rotate;
@>;
			
			



@push 1;
@if1;
	@>Branch1;
@bla;
@bla
@>Branch2;

@:Branch1;
	@push 1;
	@push 2;
	@push 3;
	@^SomeFunction; @call;

	@drop;
	@bla;@bla;@bla;

	@reset;

@:SomeFunction;
	@push 2; @over; @bla;@bla;@bla;

	@ret;


@start;@drop; @push 11111; @push 22222; @push 33333; @push 44444; @push 55555;
@here;
//@push 2; @over; @remove; @drop;
@push 4; @remove; @drop;
//~~   NEED MNEMONIC RULE;
//~~   rem - valid BEFORE pushing an index arg,
//~~   ovr - valid AFTER  pushing an index arg;
//~~ rem-before, ovr-after;

//~~   0 ovr -> ??? ERROR
//~~   1 ovr -> ??? copy/dup S0 (prior to the opd push)
//~~   2 ovr -> ??? copy S1
//~~   3 ovr -> ??? copy S2

//~~   0 rem -> ??? drop (pop S0,S1)
//~~   1 rem -> ??? remove S0
//~~   2 rem -> ??? remove S1
//~~   3 rem -> ???;

@someword1; @<; @bla;@bla;@bla; @>;
@someword2; @<; @bla;@bla;@bla; @someword1; @bla;@bla;@bla; @>;
@someword3; @<; @bla;@bla;@bla; @someword2; @bla;@bla;@bla; @>;

rotate <w 2 over 3 remove drop dup 2 add over 2 over 3 add remove 3 remove drop
drop 2 over 3 remove drop w>
  
rotate < 2 ovr 3 rem drp dup 2 + ovr 2 ovr 3 + rem 3 rem drp drp 2 ovr 3 rem drp >
  
  
cs_push; //~~ pop OpdS.S0 (label/position), push to CalS.S0[CallInfo with NO src address];
cs_pop;  //~~ pop CalS.S0[CallInfo],        push to OpdS.S0[Label];
//cs_jump; //~~ pop CalS.S0[CallInfo];

//JHDKSJDH @<w; @^LabelName; @terminate_word_and_jump_to_label; @w>



2 1 cmp =? <s bla bla bla s>;
2 1 cmp =? <s ^B1 jump s>;


///2 1 cmp =? if1[^Branch1]
2 1 cmp =? ^Branch1 jif1 else;

2 1 cmp =? ^Branch1 jif1 ^Branch0 jif0 ^BranchNull jif_null;

myword <w bla 1 bla 2 bla bla bla w> mynextword <w w>
start bla bla bla here bla bla bla reset;


@push 1;
@push 2;
@compare;
	@^Branch1;    @jif1;
	@^Branch0;    @jif0;
	@^BranchNull; @jif_null;
@^Branch;


//~~ @someword; @<w; @bla;@bla;@bla; @w>;

//~~ @drop;   @<w; @push 0; @remove; @w>;
//~~ @inc;    @<w; @push 1; @add; @w>;
//~~ @rotate; @<w; @dup; @push 1; @add; @over; @push 2; @over; @push 2; @add; @remove; @push 3; @remove; @drop; @drop; @w>;
//~~ @swap;   @<w; @push 2; @rotate; @w>;
//~~ @dup;    @<w; @push 1; @over; @w>;
//~~ @jif0;   @<w; @push 2; @over; @push 0; @compare; @push 3; @remove;
//~~ 				  @drop; @swap; @cs_pop; @jif1; @w>;




@gettype;

//@push $str;
@push _Node;

@define;
@set;
//@drop;
//@drop;
@drop;

@unfE; @drop;
@unfL; @drop;
@unfI; @drop;
@unfGB;

//@push 2; @compare;

@here;
@if1;
	@>ProcessAssignment;
@bla;@bla;@bla;
@reset;

@:ProcessAssignment;
	@bla;
	@bla;
	@bla;
	@bla;
	@bla;
	@bla;
	@bla;
	@bla;
@ret;
	
	
@here;


@:MyProc1;  //~~ defines callable procedure;
@ret;       //~~ returns control flow from procedure;
@call;      //~~ calls procedure by address in S0;

@:MyLabel1; //~~ defines label;
@^MyProc1;  //~~ pushes label address on the stack: like '@push 111';


@^MyProc1; @call;

@compare;
@if1;
	@>MyLabel;
@bla;@bla;@bla;

@if1;
	@^MyProc; @call;
@bla;@bla;@bla;


if1 ^MyProc call;

1 2 cmp if1 >MyProc   bla bla bla;
1 2 cmp >MyProc if1   bla bla bla;

1 2 =? if1 >MyProc   bla bla bla;

>? !=?  type? equals? is_empty?;
<? >? =? !=? !? type? equals? is_empty?;

0xff0000; 
0b1011001;
0t1210121;
0o12345670;
0n123456780;
0d1234567890;

121.464;

1 1f 1d;
1 1.0 1.0f;











	
//@	



//@unfE; @drop;
//@unfL; @drop;
//@unfI; @drop;
//@unfGB; @drop;







@reset;












@mul;
	@<w;
		@push 0; //~~ oValue;
		@push 0; //~~ counter;
			
		@:Mul_While;
			@dup;
			@push 4; @over; @compare; //~~ get Y;
			@if1;
				@>Mul_WhileEnd;

			@push 2; @rotate;
			@push 4; @over;
			@add;
			@push 2; @rotate;

			@push 1; @add; //~~ inc counter;
			@>Mul_While;
		@:Mul_WhileEnd;

		@pop;
		@push -3; @rotate;
		@pop;
		@pop;
	@w>;

@pow;
	@<w;
		@push 1; //~~ oValue;
		@push 0; //~~ counter;
		
		@:Pow_While;
			@dup;
			@push 4; @over; @compare; //~~ get Y;
			@if1;
				@>Pow_WhileEnd;
				
			@push 2; @rotate;
			@push 4; @over;
			@mul;
			@push 2; @rotate;

			@push 1; @add; //~~ inc counter;
			@>Pow_While;
			
		@:Pow_WhileEnd;

		@pop;
		@push -3; @rotate;
		@pop;
		@pop;
	@w>;
@start;
@:001;
	@push 2;
	@push 16;
	
	@pow;

	@here;
		
	@pop;
@>001;


iX,iY,oV $i32,$i32,$i32;

_Counter 0;

oV 0; while(_Counter < iY) //~~ not equals;
(
	oV = oV + iX;
	_Counter ++;
);


@myword;
	@<w;
		@bla;@bla;@bla;@bla;
		@ret;
		@bla;@bla;@bla;@bla;
	@w>;
@start;

@:001;
	//@myword;
	//@myword;
	//@myword;
	@^MyFunc; @call;
	@^MyFunc; @call;
	@^MyFunc; @call;

@>001;

@:MyFunc;
	@bla;@bla;@bla;@bla;@bla;
	@bla;@bla;@bla;@bla;@bla;
	@bla;@bla;@bla;@bla;@bla;
	
	@myword;
	@ret;


@fillstack; //~~ if word is unknown, push word on the stack, then continue expecting 'word-begin'/'skip-mode' instruction;
	@<w; //~~ set 'word-begin'/'skip mode';
		@:1;
		@push 1;

		@stacksize;
		@push 10;
		@compare;
		@if0;
			@>1;

	@w>; //~~ restore 'exec mode' (word's procedure body ends);
@optimizestack;
	@<w;
		@:OnceAgain;
			@stacksize;
			@push 1;
			
			@compare;
			@if1;
				@>PopAndContinue;
			@ret;

		@:PopAndContinue;
			@pop;
			@>OnceAgain;
	@w>;

@start;

@:MyTestLabel;
	@fillstack;
	@optimizestack;
	@optimizestack;
	@optimizestack;
	@optimizestack;
	@optimizestack;
@>MyTestLabel;


	@begin_word;
	@bla;
	@bla;
	@bla;
	@bla;
	@end_word;

myword1 beginword bla bla bla endword
myword1 <word bla bla bla word>;

myword1 <w bla bla bla w> myword1 <w bla bla bla w>






:myword1 bla bla bla;
:myword2 bla bla bla;
:myword3 bla bla bla;






//~~ LIST OF BASIC INSTRUCTIONS;
@push ("Value",LabelAddress,_Node);
@mode;   //~~ S0=1 -> node, S0=0 -> data/value;
@over;   //~~ must keep argument S0 on top of the stack;
@remove; //~~ must keep argument S0 on top of the stack;
@sub;
@jpos;
@call;
@<;
@>;


<,>,(push 12345),mode,copy,ins,del,sub,jpos,call;



12345,mode,over,remove,sub,jpos,call,<,>;


push drop dup rotate call return;
compare; add; if1;




@:MyFunc;
	@if1;
		@>MyFunc1;
	@ret;


 <? bla bla bla <? bla bla bla ?> ?>;


<?
	bla bla bla
	<?
		bla bla bla
	?>
?>


<?
	bla bla bla
	bla bla bla
	bla bla bla

	<*
		bla bla bla
		
	*>

	dup <? ret ?> not
	<?
		bla bla bla
		bla bla bla
		bla bla bla
	?>
?>






1 < do if there is 1 on the stack and than push 1 again >;
1 < do once because push 0 >;

0 < bla bla bla > //~~ block is skipped;
1 < bla bla bla 0 > //~~ block executes 1 time;
30 1 < -1 add  bla bla bla   dup 0 =? > //~~ block repeats 30 times;

30 1 //~~ 1 is just to enter the loop;
<
	dup

	bla bla bla

	0 =?
>
@push 30;
@push 1;
@<;
	@dup;
	@bla;@bla;@bla;

	@push 0; @equals?;
	//~~ OR;
@>;



30
:A dup 0 cmp P? < ^A >
:CycA dup 0 cmp P? < ^CycA >

< dup   while true cycle bla bla bla  0 cmp P? ^ > exiting cycle bla bla bla
< dup 0 cmp P? ^  bla bla bla bla >





@mode DATA;

@push 1;
@if1;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
@else;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;@nop;
@endif;
@reset;

1 if1 nop nop nop else nop nop nop endif reset;
1 if1 nop nop nop endif nop nop nop reset;
1 <if nop nop nop if> nop nop nop reset;
1 <? nop nop nop ?> nop nop nop reset;
1 <? >MyBranch1 ?> nop nop nop reset;
1 <? ret ?> nop nop nop reset;
1 ? >MyBranch nop nop nop reset;
1 ?>MyBranch nop nop nop reset;

1 2 + dd 3 = ?>MyBranch nop nop nop reset;

<? exec 1 time if 1 ?>
<+ exec 1 or more times while 1 +>
<* while 1 exec 0 or more times *>
<! not to exec? !>
<= =>
<~ ~>
<| |>

1 2 cmp <? bla bla bla ?> reset;
1 2 cmp <+1? bla bla bla ?> reset;
1 2 cmp <-1? bla bla bla ?> reset;
1 2 cmp <0? bla bla bla ?> reset;

1 2 cmp
	<P? bla if greater ?>
	<N? bla if less ?> 
	<0? bla if equals ?> 

30 <* bla bla bla -1 add dup 0 cmp <0? break ?> *>
30 <* bla bla bla -1 add dup 0 cmp if0 >BreakLabel; *>
<* -1 add dup 0 cmp if0 >BL0; dup if1 >BL1 *>

cmp dup 1? < bla bla bla > dup 0? < bla bla bla > pop < bla bla bla>;
cmp +1? < bla bla bla > 0? < bla bla bla > -1? < bla bla bla> pop;

dup _Str cmp
<
	+1? < bla bla bla >
	 0? < bla bla bla >
	-1? < bla bla bla >
>
pop;

<
	P? < bla bla bla >
	O? < bla bla bla >
	N? < bla bla bla >
>






@compare;
@dup;
@1?;
@<;
	@bla;
	@bla;
	@bla;
@>;
@0?;
@<;
	@bla;
	@bla;
	@bla;
@>;
@pop;
@<;
	@bla;
	@bla;
	@bla;
@>;


@push 1;
@push 2;
@add;
@dup;
@push 3;
@compare;
	G>CaseIfGreater;
	E>CaseIfEquals;
	L>CaseIfLess;
@nop;
@nop;
@nop;
reset;

@<if;
	@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;
@if>;

@<?;
	@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;
@?>;


@<?;
	@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;
	@nop;@nop;@nop;@nop;
@?>;




///_X,_Y,_Str 111,222,"Hello, World!";
///@push iForm.Children[_Index,_BlaBla (1 - 1),"Bla"; _Index].ParentForm.Name.Substring[2,6];
@mode NODE;
//~~@push _Str.Substring[2,6],_Num;
@push 24,42;
@mode DATA;







@push 30;
@push 2; @rotate; @pop;

@:CycleAAA;
	@push -1;
	@add;
	@dup;
	@push 0;
	@compare;

	@if0;
		@>CycleAAA;
	@reset;



@:BLOCK_PROCESSING__SET_RETURN_VALUE;
	@unfL;

	//~~ at least 1 item in the list specified;

	@dup; @push 0; @compare;
		@if1; @>Exit;
		@else;
		
		@dup; @inc; @rotate;

		@^PROCESS_LISTITEM; @call;

		

		@error_not_implemented_cycle;

	@push 0; @compare;
		
	@:Exit;
		@reset;

	//@dup; 
	@:PROCESS_LISTITEM;
		@push 2; @rotate;
		@dup; @inc; @inc; @rotate;

		@unfI; @dup; @inc; @rotate;
		
		@^PROCESS_ATOM; @call;
		@ret;
	@:PROCESS_ATOM;
		@ret;

		//@&IDENTIFIER?; @>PROCESS_IDENTIFIER;
		//@&IDENTIFIER?; @>PROCESS_IDENTIFIER;
		//@&IDENTIFIER?; @>PROCESS_IDENTIFIER;
		///@invoke_mode READ; //




	@push 1; @dup;

//~~ HOWTO: make popping/non-popping instructions with just a names;
@1?; @>IF_ONE;
@2?; @>IF_TWO;
@0?; @>IF_ZERO;
@NULL?; @>IF_NULL;

@TYPE?;
@I32?;
@F64?;
@STRING?; 



@pop;


@1?;
	@if1;


@mode DATA;













@:StartCycle;
		@push 0;
	@:CycleA;
		@push 1; @add; @dup;
		@push 4;
		@compare;
			@if1; @>RESET;

		@push 0;
	@:CycleB;
		@push 1; @add; @dup;
		@push 9;
		@compare;
			@if0; @>CycleB;
		
		@pop;
		@>CycleA;
	@:RESET;
		@pop;
		@bla;@bla;@bla;@bla;@bla;

		@^Start; @call;

		@bla;@bla;@bla;@bla;@bla;

		@reset;


@:Start;
	@push "Hello"; @push "Fucking"; @push "World";
	@push 1;@push 2;@push 3;
	
	@^MyProc; @call;

	@pop;@pop;@pop;

	@^ClearGreating; @call;

	@nop;@nop;@nop;@nop;@nop;@nop;


	


	@ret;
	//~~@reset;

@>Start;
@:MyProc;
	@push 4; @rotate;
	@push 4; @rotate;
	@push 4; @rotate;

	@nop;@nop;@nop;

	@pop;@pop;@pop;

	@push 111; @push 2; @rotate;
	@push 222; @push 2; @rotate;
	@push 333; @push 2; @rotate;
	
	@ret;

@:ClearGreating;
	@push 4; @rotate; @pop; 
	@push 3; @rotate; @pop;
	@push 2; @rotate; @pop;

	@ret;



@push 1;
@

@switch;
@1?;
(
	@bla;@bla;@bla;
	@bla;@bla;@bla;
	@bla;@bla;@bla;
);
@0?;
(
	@pop;
);






@gettype;
@value?; @if1; @>ASSIGNMENT__UNFOLDING_LISTITEM__PROCESS_VALUE;
@ident?; @if1; @>ASSIGNMENT__UNFOLDING_LISTITEM__PROCESS_IDENTIFIER;
@block?; @if1; @>ASSIGNMENT__UNFOLDING_LISTITEM__PROCESS_BLOCK;

block? if1 >ASSIGNMENT_PROCESS_IDENTIFIER;



@if_literal;
@if_node;
@if_ident;


@unfL;  @dup; @inc; @rotate;
@unfI;  @dup; @inc; @rotate;
@unfAB; @dup; @inc; @rotate;
@unfE;  @dup; @inc; @rotate;
@unfL;  @dup; @inc; @rotate;
@unfI;  @dup; @inc; @rotate;



@unfB;   @fldB;
@unfE;   @fldE;
@unfL;   @fldL;
@unfI;   @fldI;
@unfAB;  @fldAB;
@unfGB;  @fldGB;
@unfFB;  @fldFB;

@ufGB<:$;


@unfold_list;       @pop;
@unfold_list;       @pop;
@unfold_listitem;   @pop;
@unfold_argublock;  @pop;
@unfold_expression; @pop;
@unfold_list;       @pop;


@unfold; @pop;

//@push 2; @rotate;
@unfold; @pop;
@unfold; @pop;
@unfold; @pop;

//@push 2; @rotate;
@unfold;








@push _X;
@push _Y;
@push _Str;
//@push 3; @fold;

@push 111;
@push 222;
@push "Hello, World!";
//@push 3; @fold;
@push 3; //~~ 3 pairs specified - precomputed;



@pop;@pop;@pop;@pop;@pop;@pop;@pop;@pop;@pop;@pop;@pop;



@:Word_Assign;
	@reset;








@:Syntax_Expression_OnBegin;
@:IfExample;
	@push 1;
	@if0;
		@>IfExample;

		@bla;@bla;@bla;
		@bla;@bla;@bla;
		@bla;@bla;@bla;
		@bla;@bla;@bla;
		@bla;@bla;@bla;
	@reset;

//@:EternalCycle1;
	//@bla;@bla;@bla;
	//@>EternalCycle1;
//@:EternalCycle2;
	//@bla;@bla;@bla;
	//@^EternalCycle2; @jump;



@bla;@bla;@bla;
@bla;@bla;@bla;
@bla;@bla;@bla;
@bla;@bla;@bla;



THE LIST OF INTERNAL INSTRUCTIONS;
	@push?; @pop!; //~~ "Hello" 1 2 3  ^ ^ ^ o 1 @>End;
	@rot; @dup;

	@:LabelName;  //~~ define label;
	@>LabelName;  //~~ jump to label by name (exc if label not found);
	@jump;        //~~ jump to S0 by address (exc if addressing not a label);
	@jumpif;      //~~ if S1, jump to S0 by address (exc if addressing not a label);
	@skipif?;     //~~ if S0, skip next instruction;
	
	@if1?; @1?;
	@if0?; @0?;
	

	@type; @define; @assign/set?;
	@fold; @unfold;







//int i = 0;
//Loop:
//i = i + 1;
//if(i != 10) goto Loop;

//int a = 0, b = 0;
//LoopA:
	//a = a + 1;
	//if(a != 10){a = 0; goto LoopA;}
//LoopB:
	//b = b + 1;
	//if(b != 10){b = 0; goto LoopB;}
	//goto LoopA;

@:StartCycle;
	@push 0;
@:CycleA;
	@push 1; @add; @dup;
	@push 3; @compare; @>RESET; @jump;
	@push 0;
@:CycleB;
	@push 1; @add; @dup;
	@push 3; @compare; @not;
	@>CycleB; @jump;
	
	@pop;
	@push 1; @>CycleA; @jump;
@:RESET;
	@bla;@bla;@bla;@bla;@bla;
	@bla;@bla;@bla;@bla;@bla;
	@bla;@bla;@bla;@bla;@bla;

	@reset;


@>MyLabel1; @push 1; @>MyLabel2_Start; @jump;

@:MyLabel1;
	@reset;

@:MyLabel2_Start; @push 0;
@:MyLabel2;
	@push 1; @add; @dup;
	@push 10; @compare;
	@not;
		@>MyLabel2; @jump;
	
	@pop;
	@push 1; @push 2; @rotate;	@jump;


	





 //~~ jmp, tryjump, jif, jif1, j?;

@push 0;
@:Loop;
	@push 1; @add;
	@dup;
	@push 10; @compare; @not; @>Loop;

	//~~@push 10; @compare; @not; @>Loop; @jump;

@push "Hello";
@push 111;
@push 222;
@push 333;
@add;
@push 555; @compare; @not;

@bla;@bla;@bla;
@bla;@bla;@bla;
@bla;@bla;@bla;
@bla;@bla;@bla;
@bla;@bla;@bla;

@pop;@pop;@pop;@pop;
@reset;


0 :Loop 1 + dup 10 == ! >Loop
0 :Loop 1 + dup 10 == ! >Loop jmp

0 :Loop 1 + dup 10 == ! >Loop ^;

0 :0 1 + dd 10 = ! >0 ^;

"Hello" 111 222 333 + 555 == !
bla bla bla bla bla 
pop pop pop pop 
reset;




@:Label1;
	@bla; @bla; @bla;
	@push 1; @>Label3;
@:Label2;
	@bla; @bla; @bla;
	@push 0; @>Label1;
@:Label3;
	@bla; @bla; @bla;
	@push 1; @>Label2;





@version 0.666 alpha;
@use instructions 0.666 alpha;
@dict WORDS;
@dict INTERNAL; //~~ instructions, internal words;
@dict CUSTOM;

"World" 2 3 3 fold _Tuple assign; //~~ "World" 2 3 (3 fold) -> "World",2,3;
_Tuple unfold 3 rot; //~~ ("World",2,3) -> "World" 2 3 3 rot -> 2 3 "World";
type _Str define assign; //~~ ... "World" $str _Str define assign -> [localvar]_Str = "Hello";


@:Assign;
	typ 3 rot
	def set;
	@>End; //~~ ?? an empty stack forces 'conditional' jump like "1 @>Label";


	gettype 3 rotate
	define set;
	1 @>Return;

	t 3 r d s;














@:001 ... _X 1 == @>001 ... ret?;


@:001;
	bla bla bla;
@:002;
	bla bla bla;
	1 @>001;
@:003;
	bla bla bla;
	_X 1 eq @>002;

@:FuncCall;
	_Arg1 _Arg2 _Arg3 gfMyFunc call;
	_Str set; //~~ assigns return value to _Str;

	1 @>FuncCall;


@:FuncCall;
	@push _Arg1;
	@push _Arg2;
	@push _Arg3;

	gfMyFunc @call;

	@bla;@bla;@bla;
	@push 1; @>FuncCall;



@:Label1 @bla 1 @>Label1;

@:001 ... 1 @>001;


@:Label1;
	@push 0; @>Label1;
	@push 1; @>Label1;


	@push 1;
	@test;
	@not;
	@>Label1; //~~ if true - and only conditional jumps;


@:WhileTrue;
	@bla;@bla;@bla;@bla;
@push 1;
@>WhileTrue;
	dsfasfa;
	asfsf
	asf
	asf
	asf




@:063;
	@bla; @bla;
	@bla; @bla;
	@bla; @bla;
	@bla; @bla;
	@bla; @bla;

@push 0; @>060;
@push 1; @>063; //~~ here;
@push 1; @>070;



1 1 @if1 @>Label1;
1 1 @>Label1;




@not;
@if1;


@not; @if1; @>IfSomethingNotDefined;


@:IfSomethingNotDefined;
	@bla;@bla;@bla;
	@bla;@bla;@bla;
	@bla;@bla;@bla;
@ret;





@bla;@bla;

@:Label1;

	@push 1;
	@push 1;
	@not;
	@if1; @>Label1;
	
	@bla; @bla; @bla;

@:Label0;

//~~ registers or stack referencing?;
@0; @A; @AX; @EAX; @R1; @; @;
@1; @B; @BX; @EBX; @R2; @; @;
@2; @C; @CX; @ECX; @R3; @; @;



@push gfFunction;
@call; //~~ control returns here after the function invocation;
@bla;@bla;@bla;
@ret;



@fork @Label;

@bla;@bla;@bla;

%Target;
@bla;@bla;@bla;
@jump %Target;


%Target;
bla bla bla   1 %Target jf   bla bla;

bla bla bla   1 test %TgtIf1 %TgtIf0   bla bla;
bla bla bla   1 %TgtIf1 fork %TgtIf0   bla bla;










@push _Str;
@push "Hello, World";

@gettype;
@push 3; @rotate;
@define;

@set;


@reset;



_Str;
"Hello, World";
@gettype;
3;
@rotate;
@define;
@set;


_Str "Hello, World" @type 3 @rot @def @set;

_Str "Hello, World" type 3 rot def set;
_Str "Hello, World" TYPE 3 ROT DEF SET;

TYPE 3 ROT DEF SET;

T 3 R D S;
T3RDS;


















@push "Hello, World";
@push 111;
@push _Str;
@push 222;
@push 333;

//~~ prepare stack items order;
@push 3; @rotate;
@push 5; @rotate;

//~~ define variable;
@gettype;
@push 3; @rotate;
@define;

//~~ set value;
//@push 2;
//@rotate;
@set;

@pop;@pop;@pop;@pop;@pop;
@nop;@nop;@nop;@nop;@nop;

@reset;

//~~ _Str $type;
@define;
//~~ _Str;
@push "Hello, World!";
@push 2;
@rotate;

@set;

//~~ stack: _Str $type "Hello, World!";
//~~ stack: _Str $type;
//~~ stack: _Str $type "Hello, World!" 1;
//~~ stack: _Str $type 0;

@define; //~~ defines identifier on the stack;
@define; //~~ defines identifier on the stack;







@set_type  "System.String";
@create    _Str;
@pop       _Str;

@pop;
@pop;
@pop;

@reset;


@pop;
@pop;
@pop;



//~~ OR (unfold additionally pushes types and unfolded list's length*3);
@begin;               //~~ X,Y  222,333;
@unfold;              //~~ X,Y  222  i32  333  i32 4;

@_here_must_be_the_markers_or_counter_insertion;

//~~ 0  222  X  i32  1  333  Y  i32;
//~~ ^---------------^------ markers or count of remaining 'triplets';

@set_type; //~~ 0  222  X  i32  1  333  Y;
@define;   //~~ 0  222  X  i32  1  333;
@assign;   //~~ 0  222  X  i32  1;
//~~ loop; 
@if1; //~~ hey, how to jump?;
           //~~ 0  222  X  i32;

@set_type; //~~ 0  222  X;
@define;   //~~ 0  222;
@assign;   //~~ 0;

@if1;

@_push_return_cmd;
@_exec;
@_restore_context_to_parent_scopes_state;





@_if_there_are_more_items_loop_cycle;




@rotate;              //~~ _X,_Y  2  2  3;

@push 2;              //~~ (_X,_Y) (2,3) (2) (2) (2);
@mul;                 //~~ (_X,_Y) (2,3) (2) (4);
@push 1;              //~~ (_X,_Y) (2,3) (2) (4) (1);
@add;                 //~~ (_X,_Y) (2,3) (2) (5);
@push 2;              //~~ (_X,_Y) (2,3) (2) (5) (2);
@rotate;              //~~ (2) (5) (_X,_Y) (2,3);
@unfold;              //~~ (2) (5) (_X,_Y) (2) (3);




@begin;               //~~ (_X,_Y) (2,3);
@get_list_length;     //~~ (_X,_Y) (2,3) (2);
//@swap_last;           //~~ (_X,_Y) (2) (2,3);
//@unfold;              //~~ (_X,_Y) (2) (2,3) (2) (3),    or pop (2,3)?;
@dup;                 //~~ (_X,_Y) (2,3) (2) (2);
@push 2;              //~~ (_X,_Y) (2,3) (2) (2) (2);
@mul;                 //~~ (_X,_Y) (2,3) (2) (4);
@push 1;              //~~ (_X,_Y) (2,3) (2) (4) (1);
@add;                 //~~ (_X,_Y) (2,3) (2) (5);
@push 2;              //~~ (_X,_Y) (2,3) (2) (5) (2);
@rotate;              //~~ (2) (5) (_X,_Y) (2,3);
@unfold;              //~~ (2) (5) (_X,_Y) (2) (3);





unfold_list;         //~~ (_X,_Y) (2,3) (2) (3);

@rotate;              //~~ (_X,_Y) (2,3) (2) (3);




@set_type "System.Int32";
@push     2;
@push     3;

@create   _X;

@pop;
@pop;
@nop;


"SYN[Program.Begin/End]"; //~~ block;
"SYN[Block.Begin/End]";

"SYN[Expression.Begin/End]";
"SYN[List.Begin/End]";
"SYN[ListItem.Begin/End]";
"SYN[ListSubItem.Begin/End]";

"SYN[Block.Enter/Exit]";
"SYN[.]";
"SYN[.]";
"SYN[.]";
"SYN[.]";

//~~ handler categories;
"LEX[]" {}; //~~ lexical   (individual tokens);
"SYN[]" {}; //~~ syntax    (AST structures);
"SEM[]" {}; //~~ semantics (words);
"FUN[]" {}; //~~ functions (function calls);



"Semantics[Expression.Begin?]"  {};
"Semantics[Expression.End?]"    {};
"Semantics[List]"               {};
"Semantics[ListItem]"           {};
"Semantics[ListItemSubItem]"    {};

"Instruction[push]" {};
"Instruction[add]"  {};

"Word[+]"  {};
"Word[=]"  {};

"+"  {};
"="  {};

"OnBeginExpression"    {}; //~~ semantic handler;
"add"                  {}; //~~ interpreter instruction;
"+"                    {}; //~~ word;


add eax,1;
add 1;


"+" {Math.Add[$<1,$>1]};

_Dict dict ("K","V"; "K","V"; "K","V");
_Dict dictionary //~~ 'dictionary' can modify the behavior of (next) operand block;
(
	"Key1","Value1"; //~~ expressions of type "$str,$str" can set dictionary values;
	"Key2","Value2";
	"Key3","Value3";
	"Key4","Value4";
	"Key5","Value5";
); //~~ restoring default/parent behaviour on expression end;




2,3,"string";//~~ simple list found;
"proc: list"
{
	???;
};
42;//~~ simple item (literal, identifier);
"proc: list_item"
{
	
};
iForm.Name.ToString[]; //~~ simple subitem;
"proc: list_sub_item"
{
	
};

"proc: set_return_value"
{
	
};

_X 1;
"proc: assignment"
{
	
};

iName,iValue,oStatus $str,$i32,$bin;
"once: signature"
{
	
};


//~~ simple define;

_X 1;

_Scope.Operands[0,1];

//@unfold list 
//~~ operands are already on the stack?;
//@pushopd 1;
//@pushopd 1;

@swap; //~~ swap stack's 0,1;

@set_next_type $i32;
@new_var       _X;
@use _X;
@pop_to;




@pop;






//@opd
//@pop



@push 2;
@push 3;
@add;
@pop oRes;
@retv; //~~ return with Value (stack top);


//~~ current scope operations;
//~~ word operands at expression level;
//~~ word operands at block level (scope);
//~~ ;

1; //~~ return value;


"^"
{
	push_op i0;
	retval;
	pop;
	ret;
};



getl 0;
setl 0;




@load _X;
@load _Y;
@pop;
@pop;

~push 1;
~push 2;
~add;
~pop;
~add;




{@read iS0; @set_ret_list iS0}; //~~ set return values (list);

{
	@push iS0;
	!push iS1;
	push s1;
	push s2;
	`push

	`push 1;
	`push 2;
	`add;
	`pop  1;
	`mul  2;
	/add 1;

	/push 1;
	/push 2;
	'push;
	'add;

	nop;
	nop;
	nop;
	nop;
	nop;



	@set_ret_list iS0}; //~~ set return values (list);


2,3;

"^" {}; //~~ ??? set return values (list);
"=" {}; //~~ assignment expression (statement);



2,3; //~~ basic expression sets return values;
2,3; //~~ equals 2,3 ^;

_X,_Y 2,3;               //~~ equals  _X,_Y 2,3 =;  


_MyF {2,3};

w23 {2,3};
1 w23 4 +;


"+" {>1; i0,i1,o0 $num,$num,$num; Math.Add[i0,i1]};
"+" {Math.Add[%-1,%+1]};
"+" {skip 1; get 0; get 1; add; clear 2; push};
queue?;
2,3;

{
	        //~~ inputs: [2 3];
	get 0;  //~~ [2];
	get 1;  //~~ [2 3];
	add;    //~~ [2 3 5];
	 clear; //~~ ???;
	clab0;  //~~ [5];
	ret 0;  //~~ ^5;


	add;   //~~ inputs are already in the stack/queue;
	clab0; //~~ [2 3 5] -> [5];
	ret;
};



_X,_Y  2,3;
_T     2,3;

_X,_Y  _T;







_MyF {iV0,iV1,oV0,oV1; 4,5};

_MyF[2,3];






///_MyFuncOut    {o1,o2;       2,3}; //~~ returns tuple or 2 values?;
_MyFunc  {i0,i1,o0,o1; i1,i0}; //~~ returns tuple or 2 values?;
_X,_Y   _MyFunc[2,3]; //~~ if tuple - unfolding,  else - assignment;
_XY     _MyFunc[2,3]; //~~ if tuple - assignment, else - folding;

_XY _X,_Y;

_AB _MyFunc[_XY]; //~~???;
_AB _MyFunc[_XY.0,_XY.1]; //~~???;
_AB _MyFunc[_XY[0],_XY[1]]; //~~???;


_Array.0;
_List.0;
_List.cI;
_Array.cItemIndex;

_MyFunc  {i0,i1,o0,o1; i1,i0}; //~~ returns tuple or 2 values?;
_X,_Y   _MyFunc.(2,3); //~~ if tuple - unfolding,  else - assignment;
_XY     _MyFunc.(2,3); //~~ if tuple - assignment, else - folding;

_XY _X,_Y;

_AB _MyFunc.(_XY); //~~???;
_AB _MyFunc.(_XY.0,_XY.1); //~~???;
_AB _MyFunc.(_XY.(0),_XY.(1)); //~~???;




0.123456789
0.123;
.123; //~~ XXX;

.123 .123 .123;

_X .123;

0 .123;







_
SO...







//~~ TYPE CASTING;
_Str ($str _Num); //~~ (string)_Num;
_F32 ($f32 _F64);

_X ($f32 Math.Sin[_Angle]); //~~ $f32;
var _X = (float)Math.Sin(_Angle);
_X = (f32)Math.Sin(_Angle);

_X Math.Sin.(_Angle).f32;
_X Math.Sin[_Angle].f32;

_X Math.Sin[_Angle].f32;

_Num 1;
_Str "Hello";


WriteLine[_Str + _Num.ToString[]];
WriteLine[_Str + _Num];
WriteLine[_Str + ($str _Num)];





_X   1;
_Y   2;
_Str "Hello";



//~~~~~~~~~~~~~;
_Str           _Array[0];
_Array[0,_Str];

_Str      _Array[0];
_Array[0] _Str;

//~~~~~~~~~~~~~;
_Str _Array[0];
_Array[0,_Str];


_Name   _Dict["name"];
_Dict["name","Vasya"];
_Dict["name"]   "Vasya";




//~~ SYNTAX NODE NAME FOR TUPLE: Group, Batch, Cluster, Section;

What to do with the GroupingBlock?
(
	
);

GroupingBlock (---); -> ???
ArgumentBlock (---); -> Invocation(Args)Block

FunctionBlock (---); -> CodeBlock, (Sub-)ProcedureBlock, (Sub-)Program
							-> DelayedExec?, 
							-> CallableBlock
							-> 
							-> 
							-> 
Subprograms may be defined within programs, or separately
in libraries that can be used by multiple programs.
In different programming languages, a subroutine may be
called a procedure, a function, a routine, a method,
or a subprogram. The generic term callable unit is
sometimes used.



So, 

//~~ IF TUPLE WOULD BE THE PRIVATE CASE OF "ITEM";
//~~ - function argument groups will be tuples anyway...;
_Array[0  ]  "Hello";
_Array[0,1]  "Hello","World";


_IsEQ {i0,i1,o0 $num,$num,$boo; o0 Math.TestEqual[i0,i1];};

_IsEQ[0,1];

_X,_Y 0,1;
_XY 0,1;
_IsEQ[_XY]; //~~ to unfold folded?;



//~~ IF TUPLE WOULD BE A GENERAL CASE;
//~~ HOW TO: 1-tuple casting to single value;

_XY   SinCos[_Angle]; //~~ 2-tuple;
_X,_Y SinCos[_Angle]; //~~ 2-tuple, unfolding;
_X    Sin[_Angle];     //~~ 1-tuple, conversion;
_Y    Cos[_Angle][0];  //~~ 1-tuple, first item access;

_A Atan2[Cos[_A],Sin[_A]];



_XY   SinCos.(_Angle); //~~ 2-tuple;
_X,_Y SinCos.(_Angle); //~~ 2-tuple, unfolding;
_X    Sin.(_Angle);     //~~ 1-tuple, conversion;
_Y    Cos.(_Angle).(0);  //~~ 1-tuple, first item access;

_A    Atan2.(Cos.(_A),Sin.(_A));


//~~ X-tuple -> tuple;
//~~ 2-tuple -> tuple;
//~~ 1-tuple -> implicit conversion to first item;
//~~ 0-tuple -> implicit conversion to void?;





_X 1;
_Y 2;




_X _Array[12];
_X ++;
_Array[12] _X;

_Array[12] ++;


















!!! How to 


SOLVED: single item-to-tuple IMPLICIT conversion/casting:
1 + 2;
where + is
{
	i0 t[$num]; //~~;
	i1 t[$num];
};




Array accessor for single item (getter)
{
	iIndex,iValue,oValue $i32,$str,$str;

	get
	{
		oValue $.GetArrayItemValue[this,iIndex,iValue];
	};
	set
	{
		oValue $.SetArrayItemValue[this,iIndex,iValue];
	};
};
Array accessor for single item (getter)
{
	iIndex,oValue $i32,$str;

	oValue $.SetArrayItemValue[this,iIndex,iValue];
};
Array accessor for single item (setter)
{
	iIndex,iValue,oValue $i32,$str,$str;

	oValue $.SetArrayItemValue[this,iIndex,iValue];
};


_Array[12] "Hello"; //~~ 1x1 args specified; 

Array accessor for multiple items
{
	sig    iIndices,iValues,oValues T[$i32],T[$str],T[$str];
	or sig iIndices,T[$i32] iValues,T[$str] oValues,T[$str];

	or sig
	iI0,iI1,iI2,$i32,$i32,$i32
	iV0,iV1,iV2,$str,$str,$str
	oV0,oV1,oV2 $str,$str,$str;


	oValues $.SetArrayItemValues[this,iIndices,iValues];
};
_Array[0,12] "Hello","World";






iForm.ParentForm.Project[2];
iForm.ParentForm.Project[2,3,4];
iForm.Name,iForm.Project[];

_X ++;
2 + 3;
class ClassName is BaseClassName
(
	has Field1;
	has Field2;

	can Mathod1 {};
	can Mathod2 {};

	can ToString {this?.Name};
);

_X    Math.Sin    [_Angle];
_X,_Y Math.SinCos [_Angle];

_XY Math.SinCos[_Angle];
_XY _X,_Y;

_X,_Y,_Z 1.0,2.0,3.0;
_X,_Y,_Z   Math.SinCos[_Angle],3.0;
(_X,_Y),_Z Math.SinCos[_Angle],3.0;

_XY Math.SinCos[_Angle];
_X,_Y,_Z   _XY,_Z;
_XYZ       _XY,_Z;
_X,_Y      _XYZ[0],_XYZ[1];
_X,_Y      _XYZ[0,1];
_XY        _XYZ[0,1];

_XYIndicesT 0,1;
_XY         _XYZ[_XYIndicesT]; //~~ accepts 1,2,3 items (parametric polymorphism);
_XY         _XYZ[0,1];         //~~ 2 in, 2 out: i0,i1 o0,o1;


_XY Sin[_Angle],Cos[_Angle];


SinCos[_Angle]






//~~ Tuple of tuples: how to pass, detect, access;

2,3; //~~ anonymous tuple;


_Tuple 2,3; //~~ anonymous folded tuple is assigned to identifier;
_X,_Y,_Str 2,3,"Hello"; //~~ anonymous folded tuple is unfolded to individual identifiers;

_TupleA _X,_Y;
_TupleB 5,6;

_TupleC _TupleA[0],_TupleB[0]; //~~ refolding to another tuple;

_MyFunc {i0,o0 ($i32,$i32),($str,$i32); "Hello, World!",iTuple[0]};

_MyFunc [2,3];
_MyFunc [_X,_Y];
_MyFunc [_TupleA];
_MyFunc [_TupleA,_TupleB]; //~~ ????!!!!;


_Tuple _X,_Y; //~~ ;



$T1 $T2; //~~ invoke T1 with T2 (not only assignment);
_Name       "Vasya";
_Name,_Age  "Vasya",20;
_Name,_Age  _User.NameAndAge;
_Name,_Age  _User.GetNameAndAge[];



_Angle (30 * Math.DTR);
_X Math.Sin[_Angle];
_Y Math.Cos[_Angle];


_Tuple Math.Sin[_Angle]; //~~ tuple of 1 item (value);
_X _Tuple[0];

_X Math.Sin[_Angle][0];  //~~ HOW TO: extract 1 item with terse code;
_X Math.Sin[_Angle];     //~~ ;


_TupleXY _X,_Y;
_TupleYX _Y,_X;

Math.Atan2[_Y,_X];     //~~ HOW TO: resolve 1(tuple) or 2(values) items;
Math.Atan2[_TupleYX];


_Func
{
	iAngle,oX,oY $f32,$f32,$f32;

	_X,_Y;
};







_Angle (30 * Math.DTR);
_X,_Y Math.SinCos[_Angle];






_Func {code goes here};   //~~ func assignment;
_Func[0,1,2];             //~~ func call with 1 arg tuples;
_Func[0,1,2] "H",",","W"; //~~ func call with 2 arg tuples;
_Func[0] "H" 1;           //~~ func call with 3 arg tuples;

_Func[] "Hello,World";    //~~ ??;
_Func[] {code};    //~~ ??;

//~~ tuple folding;
_X,_Y,_Z   1,2,3;
_XYZ _X,_Y,_Z;



//~~ Tuples as nested ordered pairs (en.wiki:Tuple);
_X,_Y,_Z 1,2,3;
_XYZ _X,_Y,_Z;


_YZ _Y,_Z;
_XYZ _X,_YZ; //~~ tuples in Set Theory;

_X,_Y,_Z 1,(2,3); //~~ ???;
_XYZ _X,(_Y,_Z);
_XYZ _X,_YZ;
_XYZ (_X,(_Y,_Z));

_X,_Y,_Z (1,2,3);


_Name,_Surname,_Age   _User.AllInfo;

_User.AllInfo _Name,_Surname,_Age;

$AllInfo _User.AllInfo;
_User.AllInfo $AllInfo;


_AllInfo _User.AllInfo;
_Name $AllInfo[0]; //~~ ??;


_X,_Y Math.SinCos[_Angle];
_SinCos Math.SinCos[_Angle];

_X Math.SinCos[_Angle][0];
_Y Math.SinCos[_Angle][1];

_X Math.SinCos[_Angle];



_SinCos Math.SinCos[_Angle];

_X,_Y Math.SinCos[_Angle];   //~~ tuple unfolding;
_SinCos Math.SinCos[_Angle]; //~~ tuple to tuple;

_X Math.SinCos[_Angle] ??;      //~~ tuple item extraction;
_X Math.SinCos[_Angle] 0;      //~~ tuple item extraction;
_Y Math.SinCos[_Angle] 1;      //~~ tuple item extraction;

_X _SinCos 0;
_Name _AllInfo 0;
_Age  _AllInfo 2;
_Age  _AllInfo[2];




_FuncArray FuncArray[10];

_Func0  _FuncArray[0];
_ResT   _Func0[0,1,2];
_R0     _ResT[0];
_R0,_R2 _ResT[0,2];
_R02T   _ResT[0,2]; //~~ folding!;

_F5R02  _FuncArray[5][0,2]; 

_AllUserInfo _UserFullNameAndAge,_UserOtherInfo;
_UserName _AllUserInfo[0][0];
_UserAge  _AllUserInfo[0][2]; //~~_UserFullNameAndAge[0];

_UserAgeAndAgeAgain _AllUserInfo[0][2,2]; //~~;



_GNWFIN (Math.GetNumWithFlagIfNaN {iNum,oNum,oFlag $f32,$f32,$i01; iNum,Math.GetRandomBool[]}) //~~ is NaN;


_Num?         _GNWFIN[3.1415]; //~~ folded...;
_Num,_IsNaN   _GNWFIN[3.1415];
_Num          _GNWFIN[3.1415][0]; //~~;
_IsNaN        _GNWFIN[3.1415][1];


_ResT  _GNWFIN[3.1415];
_IsNaN _ResT[1];



Array indexer
{
	iIndices,iValues,oValues $tuple[$i32,$etc],$tuple[$str],$tuple[$i32,$etc];

	i0       iIndices; //~~ unfolding by signature;
	i0,i1    iIndices;
	i0,i1,i2 iIndices;
	i0,i1,i2 iIndices[0,1,2];


	
};

_T1,_T2  Tuple1,GetTuple2[];
_T1,_Err GetTuple1WithError[];

_T1      GetTuple1_CheckError[][0];
_Err     GetTuple1_CheckError[][1];
_T1,(_Info2,_Err2) GetTuple1_CheckError[];

_T1,(_Info2,_Err2)   _T1,_T2;
_T12   _T1,_T2;
_T12   _T1,(_Info2,_Err2);
_Err2  _T12[1][1];



_Array[0]     "Hello";
_Array[0,1,2] "Hello",",","World";

_Array;       //~~ class instance;
_Array[0];    //~~ ??? returns tuple or tuple item?;
_Array[0][0]; //~~ returns tuple item;









_Num,_Str 1,"Hello, World";

2 + 3;

_Form.ParentForm.Title[0] "X";
//~~ ;

//~~ how to assign;
_X _Array[12];
_X ++;
_Array[12] _X;

_Array[12] ++;

//~~ getter and setter functions arguments;

_Int32Array indexer
{
	sig getter (iIndex,oValue $int,$int); //~~ getter only;
	sig setter (iIndex,iValue $int,$int); //~~ setter only;

	for getter
	(
		oValue $.Array.GetValue[this, iIndex];
		ret oValue;
	);
	for setter
	(
		$.Array.GetValue[this, iIndex, iValue];
		ret iValue;
	);
};
_Int32Array indexer
{
	iIndex,oValue $int,$int; //~~ getter only;
	(iIndex,iEtc iValue) (oValue,oCallbackFunc); //~~ setter only;

	//~~ get _Array[12][0];
	//~~ set _Array[12][1]["Value"] ; //with callback function

	for getter
	(
		oValue $.Array.GetValue[this, iIndex];
		ret oValue;
	);
	for setter
	(
		$.Array.GetValue[this, iIndex, iValue];
		ret iValue;
	);
};
this.Name getter
{
	i0,i1,i2,i3  o0,o1;
};
this.Name setter
{

	i0,i1,i2,i3 o0,o1;

	i_0,i_1,i_2,i_3;
	
	i$0; //~~??;

	_Name, _Ident;
	word;
	2 + 2;
	2 $w012 2;


	swap _X1,_X2;
	{
		get $1; set _1;
		get $2; set _2;

		get _1; set $2;
		get _2; set $1;
	};

	_X1 ++;
	{
		get $1;
		set _1;

		new  1;
		set _2;

		push _1;
		push _2;
		add;
		pop _3;
		set $1;

		cls; //~~ clear/reset stack/list;
	};
	_Num ++;
	{
		get i0;
		add 1;
	};
	_X + _Y;
	{
		def _0; def _1; def _Res;

		get i0; set _0;
		get i1; set _1;

		push _0;
		push _1;
		add;

		pop _Res;
	};

	_X + _Y;
	{
		def _Res;

		push i0;
		push i1;
		add; //~~ pops 2 items, pushes 1;

		pop _Res;
	};

	_Num ++;
	{
		pop _Num;
		add _Num,1;
		push _Num;
		ret;
	};
	_X1 + _X2;
	{
		sig >;

		pop _X1;
		pop _X2;

		def _Res;
		mov _Res _X1;
		add _Res,_X2;
		
		push _Res;
		ret;
	};
	_X1 _X2 =;
	{
		def _S;
		def _T;

		pop _S;
		pop _T;

		get _S,ALL;
		set _T,ALL;
	};
};




???
{
	^Name "Vasya";
	_X ^Name;

};


$.Math.Add[2,3];
$.String.Concat["Hello"," ","World!"];


_X $.Math.Add[_X,3];




+
{
	$<1,$>1,$R $obj,$obj,$obj;

	//$>1; //~~ move one step forward (delay execution to next operand);

	$.ExecStackOperand[0]; //~~ STACK?... or list?;
	$.ExecStackOperand[1];

	o1 $.Operators.Add[i1,i2];
};
=
{
	//$i1,$i1,$o1 $num,$num;
	>1; //~~ move one step forward (delay execution to next operand);
	

	i1,i2,o1 $obj,$obj,$obj;

	
	$.ExecStackOperand[0]; //~~ STACK?... or list?;
	$.ExecStackOperand[1];

	$.GetStackOperand[0];
	$.GetStackOperand[1];



	$.Operators.Assign[i1,i2]; //~~ internal function call?;
	$.Save

	$.[];
	$.[];
	$.[];
	$.[];
	$.[];

	//_Opd1 i1;
	//_Opd2 i2;

};


1 + 2;

_X + _Y;
_X ++;

iUser.Age.ToString["%"] + " years old";

oStr (iUser.Age.ToString["%"] + " years old");


if it is true then add 1 to Something
else return gNothing;

if (this is true) (add 1 to Something)
else              (return gNothing);


put iThing to second gShelf;


iUser.Name "Vasya";
iUser.Name "Vasya" =;


_X =   2 * 2  +  3 * 3;
_X =  (2 * 2  +  3 * 3);
_X = ((2 * 2) + (3 * 3));






1; 2,3; 4,5,6;
1  2,3  4,5,6;

(1; 2,3; 4,5,6);

_Value (1; "Two",3.1415f; 4,"Five","Six");


_VInt32,_VFlo32,_VFlo64,_VStr,_X,_Y
24,3.14157965f,3.14157965,"Hello, String!",1.0,2.0;


HEY!;

+ {>> 1; Math.Add[$2,$1]};
1 + 2;     //~~  -> (1 2 +);
1 + 2 + 3; //~~  -> (1 2 +) 3 +;

1 2 +;

+ 1 2;
1 + 2;
1 2 +;


"Hello " + iUser.Name;
Math.Sin[_A] * 2;





class
{
	>|; //~~ move to the end of expression;

	if(STACK SIZE IS 4) //~~ the class as a single expression;
	if(STACK SIZE IS 2)

	if    ($2 is? "is") ($.DefineClassWithBase[$4,$2,$3,$4])
	else                ()$.DefineClass[$4,$2,$3,$4];
}; 
is    {>};



+
{
	$.Stack.Push[$<1];
	$.Stack.Push[$>1];

	$.Math.Add[$-2,$-1];
};

=
{
	
};

_X = 1;
_Y = _X;
_Z = (_Y + _X);


class Human is Animal {~~~}; //~~ ->| = to end;
      Human is Animal {~~~} class;




class Animal          (has Something);
class Human is Animal (has Something; has SomethingElse);





//_VInt32 24;
//_VFlo32 3.14157965f;
//_VFlo64 3.14157965;
//_VStr "Hello, String!";
//_X,_Y 1.0,2.0;

//_VInt32,_VFlo32,_VStr;
//_VStr,_X,_Y;




//iName;
//iAge;
//oMessage;
//_HW;

$.Function1[];
$.Function2[24];
$.Function3["Vasya","Pupkin",17];

$.AAA;
$.BBB;
$.AAA,$.BBB;
$.AAA,$.BBB  $.CCC;

$.Function1[1];
$.Function2[1,"Hello"];




1;
2;
3      4;
5,6,7  8;

"Hello";
"Hello","World!";
"Hello",24;








1,2,self;
_X self;

let be own self;

let,be,1;

this[0] = 1;

this _X[1] = 2;

this.Name;
this[0].name[1];

name.name.name;
name.iName;
iName.name;

iName.oName;
_X.name;




_X 2;
_Y 3;

_Z Math.Add[_X,_Y];
_Z (_X + _Y);


cycle
(

);

for cI (0 .. 100)
(

);

for cI (0 .. 100)
(

);


"..." {};

0 .. 1e3;





for (cI 0)(cI < 100)(cI ++)
(
	
);


class Human
{
	has Name;
	has Surname;
	has Age;

	can check IsAlive {true};
	can check IsDead  {not $.IsAlive};

	can Eat   {};
	can Sleep {};
	can Shit  {};

	static
	(
		
	);
};



iNode["@name"].ToString[];

iNode.Name;
iNode.Name.Name.Name;
iNode.Name.Name.Name, iUser.Age.Age;





iNode["@name"];
iNode.Name.IndexOf["Abc"];
iNode.Name.IndexOf["Abc"].ToString[];



_Name,_Pos
(
	iNode.Name.IndexOf["Abc"].ToString[],
	iNode.Children[1]["@name"],
	iNode["@position"]
);

1 + 1;

class Human
{
	has Name;
	has Surname;
	has Age;
};

1(2);
""(1.0 1.0);
"" (1.0 1.0);

""(1.0,1.0);
"" (1.0,1.0);

("1");
("1" ("2" ("3")));
("1" {"2"});

1, 2, 3     4, 5;

1,2,3,4,5;      1, 2, 3, 4, 5;
1,2,3 4,5;      1, 2, 3  4, 5;

1,2,
3
4,5;

"1""2";
"1" "2";

"1"2.0;
1.02.0;








1 2 3 + 5;
1,2 3 + 5,5;
1,2,3 + 5,5 - 6;

(1 2 3);
(1,2 3);
(1,2,3);

(1 2 3)   1 2 3;
(1,2 3)   1,2 3;
(1,2,3)   1,2,3;

(1 2 3) + 1 2 3;
(1,2 3) + 1,2 3;
(1,2,3) + 1,2,3;

(1 2 3) + 1 2 3 + 5;
(1,2 3) + 1,2 3 + 5,5;
(1,2,3) + 1,2,3 + 5,5 - 6;







_Name,_Pos iNode["@name"], iNode["@position"];

"+" {Math.Add[i0,i1]};
fSum ("ret" {Math.Add[i0,i1]})


iName _Surname oName MemberName "String" 1.0 tytyuy;
iName;iName;iName;
iName;
iName "String";
iName  "String";
iName   1.0 "String";

//~~ L0 ����������, ���!;

"
asfasfsa
";

tytyuy "Multiline st\""ringyy87y87\""uyiuiuyiuyiu
goes here

here

here
and here
and here\"sfafsafsa\""safasfsaf\"safasf
assa";




//~~ L1;
1b;2;3.1415;"string";

//~~ L2;
"one""two""three";

//~~ L3;
20070101 1.2568 1.2632 1.2541 1.2574 1656854;
//20070102 1.2568 "1.2632" 1.2541 1.2574 1656854;
//20070103 1.2568//~~ 1.2632 1.2541// 1.2574 "165"6854;
//~~20070104 1.2568 1.2632 1.2541 1.2574 1656854;
20070105 1.2568 1.2632 1.2541 1.2574 1656854;

"R1C1""R1C2""R1C3""R1C4""R1C5";
"R2C1""R2C2""R2C3""R2C4""R2C5";
"R3C1""R3C2""R3C3""R3C4""R3C5";
"R4C1""R4C2""R4C3""R4C4""R4C5";
"R5C1""R5C2""R5C3""R5C4""R5C5";

//~~ L4;
"parent"
(
	"attrName1""attrValue1";
	"attrName2""attrValue2";

	"child1"
	(
		"attrName1""attrValue1";
		"attrName2""attrValue2";

		"value1"; //~~ concatenated values;
		"value2";
		"value3";
	);
);

"html"
(
	"body"
	(
		"h1"("Hello, World");

		"table"
		(
			"tr"("td"("Name");"td"("Type");"td"("Description"));

			"tr"("td"("Node1");"td"("Element");"td"("Bla-bla-bla"));
			"tr"("td"("Node2");"td"("Element");"td"("Bla-bla-bla"));
			"tr"("td"("Node3");"td"("Element");"td"("Bla-bla-bla"));
		);
	);
);

"body"
(
	"attrName1""attrValue1";
	"attrName2""attrValue2";

	"child1"
	(
		"attrName1""attrValue1";
		"attrName2""attrValue2";

		"value1"; //~~ concatenated values;
		"value2";
		"value3";
	);
	"child2"
	(
		"attrName1""attrValue1";
		"attrName2""attrValue2";

		"value1"; //~~ concatenated values;
		"value2";
		"value3";
	);
);


//~~ L5;
"html"
(
	"head"("title"("Homepage"));

	"body"
	(
		"style" gBodyStyle;
		
		"h1"("Hello, "; _UserName);
	);
);




"struct" "Vector3"
(
	"X" "$f32";
	"Y" "$f32";
	"Z" "$f32";
);

struct Vector3
{
	X $f32;
	Y $f32;
	Z $f32;
};


"bindings"
(
	(
		"ircEvent" "PRIVMSG";
		"method"   "newUri";
		"regexp"   "^http://.*";
	),
	(
		"ircEvent" "PRIVMSG";
		"method"   "deleteUri";
		"regexp"   "^delete.*";
	),
	(
		"ircEvent" "PRIVMSG";
		"method"   "randomUri";
		"regexp"   "^random.*";
	)
);

bindings
(
	binding
	(
		ircEvent "PRIVMSG";
		method   "newUri";
		regexp   "^http://.*";
	);
	binding
	(
		ircEvent "PRIVMSG";
		method   "deleteUri";
		regexp   "^delete.*";
	);
	binding
	(
		ircEvent "PRIVMSG";
		method   "randomUri";
		regexp   "^random.*";
	);
);


"bindings"
(
	("ircEvent" "PRIVMSG"; "method" "newUri";    "regexp" "^http://.*"),
	("ircEvent" "PRIVMSG"; "method" "deleteUri"; "regexp" "^delete.*"),
	("ircEvent" "PRIVMSG"; "method" "randomUri"; "regexp" "^random.*")
);

//bindings:
  //- ircEvent: PRIVMSG
    //method: newUri
    //regexp: '^http://.*'
  //- ircEvent: PRIVMSG
    //method: deleteUri
    //regexp: '^delete.*'
  //- ircEvent: PRIVMSG
    //method: randomUri
    //regexp: '^random.*'



"html"
(
	"head"("title"("Page title goes here"));
	
	"body"
	(
		"h1"("Hello, World!");
		
		"pre"
		(
			"Current time is '", $DateTime.Now, "'";
		);
		"pre"
		(
			"Current time is '"; $DateTime.Now; "'";
		);

		"pre"("Current time is '"; $DateTime.Now; "'");

		"pre"
		(
			"Current time is '";
			$DateTime.Now;
			"'";
		);
	);
);

"Configuration"
(
	"Settings"
	(
		"Applications"
		(
			"Application"
			(
				"Name" "NGonSchemeEditor";
				"Viewpoint"
				(
					"position"          1.2553,1.265,0.563;
					"inclination"       0.5707;
					"perspective"       1.2553,1.265,0.563;
					"isPerspectiveMode" 0;
				);
			);
			"Application"
			(
				"Name"           "ModelEditor";
				"Viewpoint"      ("matrix" 1.2553,1.265,0.563);
				"RecentFileList" "MyFile1.mdl","MyFile2.mdl","MyFile3.mdl","MyFile4.mdl";
			);
		);	
	);
);


gConfig gfLoad["Config.aedl"];

gSettings gConfig["Settings"];

gApp gShell.Run["NGonSchemeEditor"];


gShell.Run
{
	sig iAppName,oAppInstance Node,ApplicationInstance;
	
	oAppInstance gfCreateApplicationInstance[iAppName];
	(
		_AppConfig   gSettings["Applications/Application[name = '" + iAppName + "']"];
		oAppInstance.ApplyConfiguration[_AppConfig];
	);
};





uhiuh;


;//~~ empty node;

_MyList List[$str];
_MyList List[$str,2];
_MyList List[$str][2];
(
	_MyList.Add["Hello"];
	_MyList.Add["World"];
);
_MyDic Dictionary[$String,$String][];
(
	_MyDic["Hello"] "World";
	_MyDic["Hello","World"];
	_MyDic["Hello" "World"];
);


class Dictionary
(
	has Indexer
	(
		get
		{
			
		};
		set
		{
			
		};
	);

	has IsEmpty (get{Count == 0});
);



//~~ -- AEDL ---------------------;

"language" "AEDL",0.0;

"program" "Boolean AND"
{
	"main"
	{
		"sig"  "i1","i2","o1" "$boo","$boo","$boo";
		"and"  "i1","i2" "o1";
		"ret";
	};

	"and"
	{
		"sig"  "i0","o0" "$boo","$boo";
		"call" "$.Logic.AND<$boo,$boo>" "i0" "o0";
		"ret";
	};
};


_X     1;
_Y,_Z  2,3;

_Name       iForm.Name;
iForm.Name  "MyForm";

iForm.Children["MyForm"].Name "MyNewForm";

iForm."MyForm"."Name"."ToString"[];



iForm.Name[0],iForm.Size     iForm.Name[0].ToUpper[],Size[320,240];

iForm.Name;
iArr[0],iForm.Children[0];

has Name $str
(
	get {$.GetFieldData[SELF,"name"]};
	set {$.SetFieldData[SELF,"name",iValue]};
);
//~~ https://ru.wikipedia.org/wiki/���������_����������;
"="
{
	_RhsVV $.InvokeList[+1, GET];
	       $.InvokeList[-1, SET, _RhsVV];
};
"=" {$-1 $+1};
"+" {Math.Add[$-1,$+1]};

_Arr[0] = 1.0;

iName[0] "X";

_Arr[0] 1.0;
_Arr[1] 1.5;


class Int32Array1 is Array1
(
	has Data $stream;

	reference
	(
		rhs
		{
			iIdx0 $ui32 {error "index is invalid or not specified"};

			$.GetData[SELF, Data, iIdx0];
		};
		lhs
		{
			iIdx0  $ui32 {error "index is invalid or not specified"};
			iValue $i32  {error "value is invalid or not specified"};

			$.SetData[SELF, Data, iIdx0, iValue];
		};
	);
);





_A,_B,(_X,_Y)         = 1,2,(3,4);
_A,_B,(_X,(_U,_V),_Y) = 1,2,(3,(5,6),4);

_U = _A,_X,(_U,_Y);

_A,_B 1,2;

//~~ ---------------------------------;

_X,_Y,_W,_H     iForm.Bounds;
_L,_S           iForm.Bounds;
(_X,_Y),(_W,_H) iForm.Bounds;
(_Loc),(_Size)  iForm.Bounds;

_FormP          Point[_Loc];
_FormS          Size [_Size];








_Ch1,_Ch2,_Ch3 gForm.Children[1].Children[2].Name.CharsAt[0,1,2].ToUpperCase[1,0,0];
_Ch1,_Ch2      iName[0,1].ToUpperCase[];
_Ch1,_Ch2      (iName[0],iName[1]).ToUpperCase[1,0];

(1,2)Member;
Array[1];
Array{1};
Array(1);

Array[1].Name;
Array.{1}.Name;
Array.(1).Name;

(_Array[0]).Name;
(_Array[0])(Name);

_Array[0](word);
(_Array)[0];



//~~word 1,,2 word ,1,2, word ,,, word , , , word;


         //_X + _Y          Sin[_A + (PI / 2)]
//_ABC = -------------     + ------------------
         //_Zdjskj             PI

         //_X + _Y          Sin[_A + (PI / 2)]
//_ABC = -------------     + ------------------
         //_Zdjskj             PI

//_ABC = ((_X + _Y) / _Z) + (Sin[_A + (PI / 2)] / PI);


{Math.Add[1,2]};
"+" {Math.Add[>0,>>0]};

if(_X < 0)
(
	//~~ do something;
)
else if(_Y > _X)
(
	//~~ do something;
)
else
(
	//~~ do something;
);



_X,_Y,_W,_H iForm.GetBounds[];        //~~ ret oX,oY,oW,oH;
_X,_Y,_W,_H (unwind iForm.Bounds);    //~~;

(_X,_Y,_W,_H) iForm.GetBounds[]; //~~ ??? one to many -> unwind;
(_,_,_W,_H) iForm.GetBounds[];
//~~(,,_W,_H) iForm.GetBounds[];

1 1; //~~ assign;
3 1; //~~ unwind & assign, optional error?;
3 3; //~~ assign;
3 2; //~~ error!;

1 1 1; //~~ assign;
1 2 1; //~~ error!;
1 2 3; //~~ error!;
2 1 2; //~~ error??? generalization?;
2 2 1; //~~ error???;


1 3;   //~~ assign list;
1 3 3; //~~ assign list;


_X,_Y 1,2;                          //~~ assignment;
iX,iY,oLen $f64,$f64,$f64;          //~~ signature;
iX,iY,oLen 0,0,0 $f64,$f64,$f64;    //~~ signature, default values;
"if","else" {},{};                  //~~ word definition;
"switch"        {}; //~~ switch;
"switch","case" {}; //~~ case inside switch?;
"for","break"   {};
3;


_X,_Y f64,f64 gfGetCoords[]; //~~ gfGetCoords[- | f64,f64];
_X,_Y f32,f32 gfGetCoords[]; //~~ gfGetCoords[- | f32,f32];


gfGetCoords_[];

class Human is Animal
{
	has Name;
	has Age;

	can Eat(iFood,iAmount,oShit $Food,$f32,$Shit)
	{
		
	};
};

_.Project (iX,iY,oX,oY $f64,$f64,$f64,$f64)
{
	
};


_User1 List[$str,$str,$i32,$i32]["Vasya","u482633",12,24];
_User2 List[$str,$str,$i32,$i32]["Vasya","f75h5r1",12,24];


_User1 List["Vasya","u482633",12,24 $str,$str,$i32,$i32];


_Name1,_Pass1 $str,$str _User1[0],_User1[1];

_Name1,_Pass1 $str,$str _User1[0,1];



$.FormatInfo
{
	iName,iAge,oHtml $str,$str,$str;

	_FstCh   iName.CharAt[0];
	_FstCh   _FstCh.Capitalize[];

	_Name   (_FstCh + iName.Substring[1,(iName.Length - 1)]);

	oHtml
	(
		"<tr>" + 
			("<td>" + _Name + "</td>") +
			("<td>" + _Age  + "</td>") +
		"</tr>"
	);
};

def FormatInfo
{
	iName,iAge,oHtml $str,$str,$str;

	_Name   (iName.CharAt[0].Capitalize[] + iName.Substring[1,(iName.Length - 1)]);
	_Age    iAge;

	oHtml
	(
		"<tr>" + 
			("<td>" + _Name + "</td>") +
			("<td>" + _Age  + "</td>") +
		"</tr>" 
	);
};
def FormatInfo
{
	iName,iAge,oHtml $str,$str,$str;

	oHtml
	(
		"<tr>" + 
			("<td>" + (iName.CharAt[0].Capitalize[] + iName.Substring[1,(iName.Length - 1)]) + "</td>") +
			("<td>" + iAge  + "</td>") +
		"</tr>"
	);
};
def FormatInfo
{
	iName      System.String;
	iAge       System.Int32;
	iSomeList  System.Collections.Generic.List[System.String];
	oHtml      System.String;

	oHtml
	(
		"<tr>" + 
			("<td>" + (iName.CharAt[0].Capitalize[] + iName.Substring[1,(iName.Length - 1)]) + "</td>") +
			("<td>" + iAge  + "</td>") +
		"</tr>"
	);
};



_Ident, cIdent, pIdent; //~~ local variables;
i0,o0;                  //~~ input arguments;
iName, oPath;           //~~ input arguments;




_X1 $f64 0;     //~~ typed assignment;
_X1 $f32;       //~~ changes the type (bitcast?);
_X1 $f32 _X1;   //~~ changes the type;
_X2 $f32 _X1;   //~~ assignment with the type casting;



(_X $f32)

{iPoint,oLength; _X,_Y iPoint.X,iPoint.Y; Sqrt[(_X * _X) + (_Y * _Y)]};

$.Length {Sqrt[(i0.X * i0.X) + (i0.Y * i0.Y)]};

$type, $i32,$f64,$str;  //~~ types;

 _UserName,_Password   "vasya","password";   //~~;
(_UserName,_Password) ("vasya","password"); //~~;

(_Identity,(_UserName,_Password)) GetAuthInfo[iUserN]; //~~;


//~~word definition;


"if","elif","else"
{
	GoTo[+1];
	Exec[];

	IfTrue[];

},
{

},
{

};


"for" {};
"for","in"

let + be {<1,>1 $i32,$i32; Int32.Add[<1,>1]};
+        {<1,>1 $i32,$i32; Int32.Add[<1,>1]};

"+"
(
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]},
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]},
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]},
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]}
);
"be"
(
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]},
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]},
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]},
	{<1,>1 $i32,$i32; Int32.Add[<1,>1]}
);


: + {};





//~~ words;


iX,iY;                   //~~arguments;
iX,iY $f64,$f64;         //~~arguments with types (sig);
iX,iY; oDist;            //~~;
iName $str; oPath $str;  //~~;

<1,>1 $str,$str; oPath $str;  //~~;


{<1,>1 $str,$str; String.Concat[<1,>1]}

iName,$str,"Default Name";



iName,iValue,(iX,iY) $str,$f64,($f64,$f64);




if(iForm.Bounds.Contains[_Point])
{

};

class Human
{
	can Eat
	{
		iFood,iAmount oResult;

		
	};
};


iX,iY $f64,$f64; oDist $f64;



_X,_Y 1,2; //~~assignment;

//~~;
//~~;
//~~;
//~~;
//~~;
//~~;
//~~;
//~~;
//~~;
//~~;





//+ {String.Concat[<1$str,>1$str]};

SayHello
{
	iName $str i0;

	iName$str i0;

	_A,_B          1,2 $i32,$i32;
	_A$i32,_B$f64  1,2;
	_Greatings     "Hello, ";
	_Name          iName;

	_Greatings + iName;
}

SayHello["Vasya"];




Form.GetClientRect{"..."};
_X,_Y,_,_ = iForm.GetClientRect[];

iForm.GetClientRect[true][2,3];

let _FormP be new Point(iForm.Bounds.X,iForm.Bounds.Y);

let _FormP be Point[iForm.Bounds[1,2]];





_S = new Size[iForm.GetClientRect[]];



fDoSomething {map (iName,iAge,(iCompanyN,iCompanyI)) $str,$str,($str,$obj)};



let cPlayerI be cName,cAge,(iCompanyN,_CompanyI);


fDoSomething with (cPlayerI);
fDoSomething(cPlayerI ^);

{map iDirPath, iFileName; oPath = iDirPath + "/" + iFileName}

def Path.GetFullPath {sig $str,$str $str; o0 = i0 + "/" + i1};
def Path.GetFullPath {o0$str = i0$str + "/" + i1$str};


DoSomething[(_A,_X),()]

_xClr,_yClr,(_X,_Y) = Color.FromArgb[1,0,0], Color.FromArgb[0,1,0], SinCos[iAngle];

_X,_Y,_W,_H = iBounds;


(_X,_Y),(_W,_H) = iForm.Bounds;

_,_,_W,_H = iForm.GetClientRect[];

iForm.GetClientRect[](_,_,_W,_H);


(_,_,_W,_) = iForm.GetClientRect[];
//~~ -,-,_W,- = iForm.GetClientRect[];

_W = iForm.GetClientRect[][2];







_xClr,_yClr,(_X,_Y)
Color.FromArgb[1,0,0],
Color.FromArgb[0,1,0],
SinCos[iAngle];


_X,_Y = _Y,_X;
swap _X,_Y;

_Angle = Atan2[_X,_Y];

_InvA = Atan2[SinCos[- iAngle]];




_X,_Y = 1,2;



//: +       {Number.Add[$<1,$>1]};
//: fGetSum {i0 + i1};


_Sum2 = 1 + 2;
_Sum1 = fGetSum[1,2];



_Vec1 = 0,0,1;
_Vec2 = 0,1,0;

_Vec3 = _Vec1 cross _Vec2;

1,2,3 length;



fDoSomething
{
	map iX,iY $f64,$f64 i0,i1;

	_X,_Y = (iX + 1),(iY + 2);

	ret
	(
		if   (_X > 0)(_X)
		else         (_Y);
	);
};







_A,_B,_XY = 1,2,(3,4);




_A,_B,_C _X,_Y,_Z;
_X,_Y,_Z 1,2,3;



let _X = Sin[iAngle];


let Atan2 be {map i0,i1 $f64,$f64; Math.Atan2[i0,i1]};

_A = Atan2[_X,_Y];
_A = Atan2[ASin[30],ACos[30]];
_A = Atan2[ASin[_A],ACos[_A]];






_Angle,(_X,_Y) = Math.Atan2[1,2], Math.SinCos[iAngle];

//_A1    = Pi / 6;
//_X,_Y  = Sin[_A1], Cos[_A1];
//_A2    = Atan2[_X,_Y];

//cA,pA,nA;
//gA,gA,pA,cA;

//_Arr.Sort[{i[0] > i[1]}];

//_Arr.Sort[{i0 > i1}];

//call _Arr.Sort with {i0 > i1};

//let fSort be {$... Sort. X.X.Y};

//fSort[_Array, 1];


//_V,_R = _MyV.Mul[iVec],_MyR.Mul[iRot];

//_SX,_CX = Sin[_X],Cos[_X];


//cForce.Update;
//cForce.Update[iDeltaT];


//_X = Vector3;
//_X = Vector3[1,2,3];

//_X = 1 + 2 * 3;
//_X = 1 + (2 * 3);


//Char[iStr[cI]];
//Char[iStr[15]];

//iObj.Children[0].Value = 1;
//iObj.Children[cChildI + 1].Value = 1;

//o[0] = i[0] * i[1];



//iObj[0][1][2];

//iObj.Children[0].Children[1].Children[2];
//iObj.Children[_X,_Y = 1,2; _Z = _X + _Y; _Z].Children[cX].Children[cY];



//i@,i0,i1,i2,...iN;
//o@,o0,o1,o2,...oN;
//>@,   >1,>2,...>N;
//<@,   <1,<2,...<N;

//2.5,1.32,6.68 * ;

//<[1];
//>[1];

//(1,2 + 3,4)         - ;
//{Math.Add(<1[0],>1[0]),Math.Add(<1[1],>1[1])};

//2 + (3 * 4);

//1. <1 = 2;
//2. op '+' for <1$i32, >1 ????k;





//{o[0] = i[0] + i[1]};
//{o0 = i0 + i1};

//{i'[0] + i'[1]};
//{o'[0] = i'[0] + i'[1]};

//o'1;
//i'[1] + i'[2];


//{o'[0] = Vector3(i'[0], i'[1], i'[2])};
//{o0 = Vector3(i0, i1, i2)};
//{Vector3(i0,i1,i2)};


//i*[cA]

//o*[cArgI] = i*[cArgI] * 2;



//_X 1;

//_X,_Y,_Z 1,2,3.0;

//@.Assign[_X, 2]; //~~ _X = 2;




//let   {I.SetMode(IMode.Define)};
//=     {I.Assign(<1,>1, 0)};
//:=    {I.Assign(<1,>1, 1)};
//be    =;

//array {I.Assign(<1, Object.Create(System.Array))};

//let _Arr be array;

//_Res Math.Add(2,3);

//_Arr.Sort({i0 > i1});

_xDate DateTime[2007,02,28, 12,53,32];
_yDate DateTime[{Year 2007; Month 02; Day 28; Hours 12; Minutes 53; Seconds 32}];
_yDate DateTime
[{
	Year    : 2007;
	Month   :    2;
	Day     :   28;
	
	Hours   :   12;
	Minutes :   53;
	Seconds :   32;
}];
_yDate DateTime[{Year : 2007; Month : 02; Day : 28; Hours : 12; Minutes : 53; Seconds : 32}];

_Var1 Math.Clamp[];
_Var2 Math.Clamp();


//~~ ---------------------------------;

$f64,"+",$f64 {Math.Add[i0,i1]};
$f64,"*",$f64 {Math.Multiply[i0,i1]};


_X,_Y (Math.Cos[_A] * 0.5 + 0.5),(Math.Sin[_A] * 0.5 + 0.5);
_X,_Y (Math.SinCos[_A] * 0.5 + 0.5);

_X,_Y ((Math.Cos[_A] * 0.5) + 0.5),((Math.Sin[_A] * 0.5) + 0.5);
_X,_Y ((Math.SinCos[_A] * 0.5) + 0.5);



i0,"+",i1 {Math.Add[($i32 i0),($i32 i1)]};


$i32,"+",$i32 {Math.Add[i0,i1]}; //~~ i32+i32;
(0,"+",1) {$i32,$i32,$i32; Math.Add[i0,i1]};
0,"+",1 {$i32,$i32,$i32; Math.Add[i0,i1]};


0,"+",1 $i32,$i32,$i32 {Math.Add[i0,i1]};


_X 1;
_Y 2;

_X._Y;
_ToS _X.ToString;

_Str1 (("Hello, " + _ToS[]) + "!");
_Str2  ("Hello, " + _ToS[]  + "!");

_X    1 + 2  * 3  / 9;
_X   (1 + 2  * 3  / 9);
_X (((1 + 2) * 3) / 9);

_X,_Y,_Z   2;
_A        (_X,_Y,_Z * 2);
_B        (_A + 2);
_C         _B,_B,_A;
_D         ??;



fG {};

fG[_X];

_X.fG[];

_X.{(_X * _X) + 2};

_X._Y.{(_X * _X) + (_Y * _Y)}[2,3];

_S (2 + 3 * 4);
_S ((2 + 3) * 4);

_S (2 + (3 * 4));
_S (2 + (3 * _X));
_S (2 + (3 * (- _X)));

_S (2 + (_Y * (- iX)));
_S (2 + ((- iX) * _Y));
_S = 2 + -iX * _Y;
_S = 2 - iX * _Y;

_S (2 + (- (iX * iY)));
_S (2 - (iX * iY));
_S (2 * (- (iX * iY)));








html
(
	head
	(
		title "Hello, World";

		meta (name = "http-equiv"; content="");
		meta (name = );
		meta ();

		link "rel","href" "stylesheet","../../css/raised-paper-2.css";
		link "stylesheet","../../css/raised-paper-2.css";
		meta "content-type" "text/html";

		meta "keywords" "kw1,kw2,kw3,kw4";

		meta
		(
			"name"    = "keywords";
			"content" = "kw1,kw2,kw3,kw4";
		);

		meta ("name" = "keywords"; "content" = "kw1,kw2,kw3,kw4";);
		meta ("name" = "keywords"; "content" = "kw1,kw2,kw3,kw4";);
		meta ("name" = "keywords"; "content" = "kw1,kw2,kw3,kw4";);
	);
	body
	(
		"bgcolor" = "#ff0000";

		"style" = "background-color: #ff0000";

		table
		(
			"cellspacing" 0;
			"cellpadding" 0;
			"border"      0;

			"cellspacing","cellpadding","border" 0,0,0;


			tr
			(
				td
				(
					"colspan" 2;
					
				);
			)
		);
	);
);


font
(
	cell
	(
		index 0;
		lines
		(
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
		)
	);
	cell
	(
		index 0;
		lines
		(
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
		)
	);
	cell
	(
		index 0;
		lines
		(
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
		)
	);
);




"font"
(
	"cell"
	(
		"index" 0;
		"lines"
		(
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
		)
	);
	"cell"
	(
		"index" 0;
		"lines"
		(
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
		)
	);
	"cell"
	(
		"index" 0;
		"lines"
		(
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
			0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 
		)
	);
);


"font"
(
	"cells"
	(
		"cell" (index 0; "lines" (0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821););
		"cell" (index 1; "lines" (0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821););
		"cell" (index 2; "lines" (0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821););
		"cell" (index 3; "lines" (0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821););
	);
);

"Singleline string";

_Text
"
|	0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821
|	0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821
|	0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821
";

class Human
{
	has Name;
	has Biography
	"
	|	0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821
	|	0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821
	|	0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821 0.5646,0.6821
	";
};

Math.Add.[1,2];
iName.ToString.[];


iName(asfasf);
iName{1,2};


_MyList List($str)[];
_MyList.Add["Hello"];
_MyList.Add[", "];
_MyList.Add["World!"];
_MyList.Concat[];




666;
		



































































































































































