(
*reset    { mode 254; };
*hault    { mode 255; };
//dup       { osp++; push 3; xmov; osp--; };
//~~dup       { xmov -1; };
*dup       { xmov -1; };
//neg       <?; dup; osp--; osp--; push 0; osp++; sub; };
*neg       { dup; xmov 0 -4; drop; drop; sub; };
*add       { neg; sub; };
*inc       { sub -1; };
*dec       { sub +1; };
*sign      { jpos ^POS; neg; jpos ^NEG; ret; :POS; ret +1; :NEG; ret -1; };
*compare   { sub; sign; };
*swap_n    { dup; dup; sub -2; xmov; dup; xmov 6; xmov 4; drop; neg; sub 2; xmov; drop; drop; drop; xmov -4; drop; drop; };
*swap      { swap_n 3; drop; };

*xget       { dup; sub -2; xmov; drop; };
*xset       { neg; sub +1; xmov; drop; drop; };
*xmovup     { xmov -3; drop; drop; };
*true      { ret 1; };
*false     { ret 0; };
*not       { jpos ^1; neg; jpos ^1; drop; ret 1; :1; ret 0; };
*make12345 { push N-111 N-2222 N-33333 N-444444 N-5555555; };
*goto      { dup; xset 1 3; csp--; jpos; };
//is-zero? { not; };
*case      { xget 3; xget 3; sub; not; jpos ^Jumping; drop;drop;drop; ret; :Jumping; xmov -3; xset 1 5; drop; drop; csp--; jpos; };
//jump      { push 1; swap; csp--; jpos; };
//jif0      { swap; dup; push ^POS; jpos; neg; push ^NEG; jpos; osp--; osp--; csp--; jump; :POS; :NEG; swap; drop; };
//jifeq
//{
//	//here;
//	dup; xmov 5; xmov 5; osp--; compare; push ^IfJumping; 
//	jif0;
//	
//	osp--;osp--;ret;
//	
//	:IfJumping; xmov -4; osp--;osp--;osp--; csp--; jump;
//};
//jif1      { here; swap; dup; push 1; sub; push ^IFJUMPING; jif0; osp--; push -3; xmov; osp--; osp--; ret; :IFJUMPING; osp--; csp--; jump; };
*equals?   { xget 2; xget 2; sub; not; xset 3; drop; jpos ^True; ret; :True; ret 1; };
*dignode   { unfold; dec; swap; };


*delete    { dup; jpos ^OK; error "WTF: non-positive offxset specified"; :OK; dup;dup; <*; sub -2; xmov; neg; sub 1; xmov; neg; sub 4; *>; drop; drop; drop; drop; };
*insert    { xget 2; xget 2; <*; push 7; xget 4; xget 3; sub; neg; sub; dup; xmov; neg; sub -1; xmov; drop; drop; dec; *>; drop; xget 2; neg; sub 4; xmov; drop;drop;drop;};

//xget; { push 0; push iA; };
//xget 5;
//xset 4;
*tsmword1
{
	push "Local" "Local" "Local";
	push "Arg1" "Arg2" "Arg3";
	tsmword2;
	here;
};
*tsmword2
{
	push "Local" "Local" "Local";
	push "RES";
	here;
	xmov -8; drop;drop;drop;drop;drop;drop;drop;
//	ret;
//	
//	xmov -8; drop 7;
//	ret 8;
};
*offxset //~~ converts stack offxset form BP-relative to SP-relative;
{
	
};
osmword1
{
	push "Local" "Local" "Local";
	//push "< oHumanInfo" "< oError";
	push "> iName" "> iAge" "> iSocNumber";
	osmword2;
	here;
	drop;drop;drop;drop;
	//ret;
};
osmword2 (iName,iAge,iSocNumber,oHumanInfo,oError)
{
	def _Local1,_Local2,_Local3;
	//~~ ================================================================;
	//~~ ========= RETURN ADDRESS BETWEEN ===============================;
	//~~ ================================================================;
	
	//~~ this requires signature processing AFTER the call (prolog and epilog);
	
	i1,i2,i3,o1,o2;                       //~~ signature known before call;
	i1,i2,i3;                             //~~ prepared inputs before call;

	
	get _1; get _2; get _3; myproc;       //~~ CALLING PROCEDURE;
	get _1,_2,_3;           myproc;       //~~ BTW, may be short form?;
	i1,i2,i3,^RET;                        //~~ pushed return address;
	
	                                      //~~ > PROLOG BEGINS;
	i1,i2,i3,^RET,o1,o2;                  //~~ pushed outputs;
	i1,i2,i3,^RET,o1,o2,_1,_2,_3;         //~~ pushed locals (if needed);
	                                      //~~ > PROLOG ENDS;
	                                      
	i1,i2,i3,^RET,o1,o2,_1,_2,_3,1,2,3;   //~~ 'pushed' anonymous stack operands;
	
	set o1; set o2;                       //~~ outputs have set;
	ret;                                  //~~ BEGIN THE RETURN FROM PROCEDURE;
	
	i1,i2,i3,^RET,o1,o2,_1,_2,_3,1,2,3;   //~~ ok, here is what we have at this moment;
	
	                                      //~~ > EPILOG BEGINS;
	i1,i2,i3,^RET,o1,o2;                  //~~ rolled SP to last output (o2);
	i1,i2,i3,^RET,o1,o2,^RET;             //~~ copied return address (if output...
	                                      //~~ ...count is greater than input's);
	o1,o2,^RET,^RET,o1,o2,^RET;           //~~ copied all the outputs plus return address;
	o1,o2,^RET;                           //~~ rolled SP to ret;
	                                      //~~ > EPILOG ENDS;
	                                      
	o1,o2;                                //~~ returned from procedure;
	
	//~~ ================================================================;
	//~~ ========= RETURN ADDRESS AFTER =================================;
	//~~ ================================================================;
	
	//~~ this requires signature processing BEFORE the call;
	
	i1,i2,i3;                             //~~ prepared inputs before call;
	i1,i2,i3,o1,o2,^RET;                  //~~ procedure has called;
	
	//~~ ================================================================;
	//~~ === OUTPUTS BEFORE INPUTS (needs complex stack operations) =====;
	//~~ ================================================================;
	
	i1,i2,i3;                             //~~ prepared inputs before call;
	o1,o2,^RET,i1,i2,i3;                  //~~ procedure called;
	o1,o2,i1,i2,i3,^RET,_1,_2,_3,1,2,3;   //~~;
	
	//~~ OR;
	
	i1,i2,i3;                             //~~ prepared inputs before call;
	i1,i2,i3,^RET;                        //~~ procedure called;
	i1,i2,i3,^RET,i1,i2,i3;               //~~;
	o1,o2,i3,^RET,i1,i2,i3;               //~~;
	o1,o2,^RET,i1,i2,i3;                  //~~;
	o1,o2,^RET;                           //~~;
	
	

	here;
	push "Local" "Local" "Local";
	push "RES";
	
	sp iName; xget;
	
	xget [offs iAge];
	sub 18;
	equals 0;
	xset [offs _Local]; 
	
	
	
	
	
	xmov _Local,iName;
	xmov _2,iAge;
	sub _2,-1;
	
	//def _1,_2,_3,_Local1;
	push 111,222,333 _Local1,_Local2,_Local3;
	
	xget iAge; xget _Local1; sub; xset oDiff;
	
	
	
	xset oError;
	
	
	//here;
	
	
	//ret 1 8 5;
	//ret[1,8,5]; //~~ oValCount, rollback;
	
	
	xmov -9; drop;drop;drop;drop;drop;
	xmovup;
	//here;
	xmovup;
	//xmovup 4;
};
!program
{
	osmword1;
//	push 1;
//	sub -5;
//	dup;
//	dup;
//	
	
	//here;
	xget 2;
	GetBaseGroupingBlock;
	//here;
	ProcessBlock;
	xmovup;
	
	here;
	unfold-list;
	drop;
	unfold-list;
	here;
};

//CallFunction;
//{
//	
//};
GetBaseGroupingBlock (iExpNode,oBlockNode)
{
	//here;
	xget 2;//dup;
	
	unfE 1; drop;
	unfL 1; drop;
	unfI 1; drop;
	//xmovup;
	xset 3;
	//here;
	//unfold; //drop;
};
ProcessBlock (iNode)
{
	//here;
	node-length; jpos ^Children;
	drop;drop; fold-list 0; ret;
	
	:Children;
		//dup;
		push "-- RETVAL --";
		//xmov "RETVALHERE" -4; drop; drop;
		//here;
		xget 2;
		unfold-node 1;
		<*;
			//here;
			//dec;
			xget 2;
			//here;
			ProcessExpression;
			//here;
			
			//xget 2;
			//here;
			//~~ xsetting return value;
			xget 4; sub -5; xset;
			
			//drop;
			//~~xget 3; xset 5;
			xmovup;//~~xset 2;
			
			//drop;drop;
			//xget 2; xset 4; xset 2;
			//dup;
			
			jpos ^NextExpression; drop;drop;
			<*;
				//~~ rexmoving queue;
				dec; xmovup;
			*>;
			drop; ret;
			
			:NextExpression;
				xmovup;
				dec;
		*>;
		//here;
		drop;


//	here;
//	x-unfold-node 1;
//	
//	dup; jpos ^Children; //~~ empty block allowed, returns empty list;
//	drop;
//	fold-list; ret;
//	
//	:Children;
//	<*;
//		dec;
//		xget 2;
//		ProcessExpression;
//		xset 3;
//	*>;
//	drop;
};
ProcessExpression (iExpNode,oList,oDoProceedNext)//~~ S0=iExpNode -> S0=oExpList,S1=oDoProceedNext;
{
	get-node-role;
		case $.SemanticRole.ExpOneList    ^OneList;
		case $.SemanticRole.ExpAssignment ^Assignment;
		case $.SemanticRole.ExpCustom     ^Custom;
		case $.SemanticRole.Unknown       ^Assignment;
		error "Not implemented";
	drop;
	
	:OneList;
		//here;
		ProcessExpression-OneList;
		ret;
	:Assignment;
		//here;
		ProcessExpression-Assignment;
		//here;
		ret;
	:Custom;
		here;
		ret;
};
ProcessExpression-OneList (iExpNode,oList)
{
	//here;
	push "NOTHINGTOWRITE";
	push 0; //~~ is write mode?;
	xget 3;
	unfE 1; drop;
	ProcessList;
	//here;
	
	xmovup;
	
	xset 1 4; //~~ do proceed next expression;
	xmovup;
	//true;
	
	
	//here;
	//drop;
	//push 1;
	//fold-list 111 222 333 3;
};
ProcessExpression-Assignment (iExpNode,oList)
{
	//here;
	dup;
	unfE 1;
	
	drop;
	//here;
	//~~ processing source list;
	push "NOTHINGTOWRITE";
	push 0; xget 4; ProcessList; xmovup; xmovup; xmovup; //here;
	unfold-list;
	
		
	dup; sub -2; xget;
	unfL 1;
	
	//~~ determining the type of assignment: list-to-list, folding and unfolding a tuple;
	dup; sub -2; xget;
	xmov 0 4; drop;
	//here;
	//~~ S0 and S1 are the list lengths;
	sub;
	not; jpos ^ListToList; error "Tuples are not implemented yet";
	
	
	:ListToList;
		dup;
		//here;
		<*;
			//here;
			//~~ computing zero-based offxset to grow;
			push 3; xget 2; sub; //neg;
			
			//here;
			//~~ list item to read;
			xget 3; dup; neg; sub; sub -4; //~~ count+count+3;
			xget 2; neg; sub; dup; //~~ adding zero-based offxset;
			xmov; drop;
			
			
			push 1; //~~ the 'write-mode' argument;
			
			//here;
			//~~ list item to write
			xget 5; xget 5; sub; sub -6; xget;
			
			//here;
			ProcessListItem;
			//here;
			
			drop;drop;drop;drop;drop;
			
//			get-node-value;// xmovup;
//			get-variable;
//			
//			here;
//			set-variable;
//			
//			
			dec;
		*>;
	
		//~~dup; sub -2; xget;
		//here;
		drop;
		<*; dec; xmovup; *>; drop;
		//here;
		fold-list;
		xset 1 4;
		xmovup;
		
		//here;
		//<*; dec; xmovup; *>; drop;
		//drop;
		//drop;
};
ProcessList (iNode,iIsWriteMode,ioValueToWrite,oList)
//~~ S0=iNode,S1=iIsWriteMode,S2=VALUETOWRITE_NOT_USED -> S0=oList;
{
	//drop;//drop;
//	fold-list 1111 2222 3333 3;
//	ret;

	//here;
	dup; unfL 1;
	dup;
	<*;
		//here;
		push "------";
		
		//here;
		//~~ node;
		xget 3; xget 3; sub; sub -5; xmov;// drop;
		//here;
		//~~ optional value to write;
		//here;
		xget 4; sub -9; dup; xmov;
		//xget 10;
		//dup; sub -5; xget;
		
		//here;
		//~~ write-mode flag;
		dup; xmov; drop;//xget 10;
		//xget 2; sub -5; xget;
		
		//~~<?; here; ?>;
		
		xget 4;
		//here;
		ProcessListItem;
		//here;
		
		xmov -7;  drop; drop; drop; drop; drop;
		neg;
		xmov;     drop; drop;
		
		dec;
		//here;
	*>;
	//here;
	drop;
	fold-list; //~~ expects [Count,Item1,Item2, .. ItemN];
	//xmov -4; drop; drop; drop;
};
ProcessListItem (iNode,iIsWriteMode,iValueToWrite,oList)
 //~~ S0=iNode,S1=iIsWriteMode,S2=iValueToWrite(opt); -> S0=oList(opt);
{
	//xget 2; <?; here; ?>; drop;
	
//	fold-list 111 2222 3333 3;
//	
//	ret;
	
	//here;
	//xget 2;
	//drop;
	//~~ can return folded list;
	push "-- MEMBERBASE --";
	xget 2;
	
	unfI 1;//here;
	<*;
		//here;
		dup;
		//~~ if is last atom in list-item (uses write-mode flag);
		equals? 1; <?; xmov 7; drop; ?>;
		
		//drop; 0 - [iIsWriteMode = 0];
		//dup;
		//~~ value-to-write;
		xget 2; sub -6; xget;
		//~~  write-mode flag;
		xget 2;
		//~~ member base;
		xget 4; sub -5; xget;
		
		//here;
		///xget 4; <?; here; ?>; drop;
		xget 6;
		//here;
		ProcessAtom;
		
		//here;
		//xget 4; <?; here; ?>; drop;
		//here;
		
		xget 7; sub -8; xset;
		drop; drop; drop; drop; drop;
		xmovup;
		dec;
	*>;
	//here;
	drop;
	//xset 3; drop;
};
ProcessAtom (iNode,iMemberBase,iIsWriteMode,iValueToWrite,oValue)
//~~ S0=iNode,S1=iMemberBase,S2=iIsWriteMode,S3=iValueToWrite(opt); -> S3=oValue(opt)
{
	//~~xget 3; <?; here; ?>; drop;
	
	xget 3; jpos ^WriteMode; drop;
		ProcessAtom-Read;
		ret;
	:WriteMode;
		ProcessAtom-Write;
		ret;
//	
//	//here;
//	//error "NI";
//	//drop;
//	dup;
//	is-node?;
//	<?;
//		drop;	
//		//here;
//		//push $.SyntaxNodeType.NumInt31;
//		get-node-type; //dup; sub 0; here;
//			case $.SyntaxNodeType.NumInt32 ^NumInt32;
//			case $.SyntaxNodeType.String   ^NumInt32;
//			//~~case 19 ^LocalIdentifier;
//			//case LocalIdentifier ^LocalIdentifier;
//			case $.SyntaxNodeType.Identifier      ^Identifier;
//			case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
//			
//			case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
//			case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
//			
//			error "Unresolved";
//		
//		:NumInt32;
//			//here;
//			//drop;	
//			get-node-value;
//			
//			//here;
//			goto ^EONode;
//			
//		:Identifier;
//			//here;
//			//~~push 0; push 5; xmov; drop;
//			xmov 0 5; dup; xmov; drop;
//			//here;
//			get-node-value;
//			get-member;
//			xmovup;
//			
//			//dup;
//			//xset "------" 2;
//			//here;
//			//~~push -4; xmov; drop; drop; swap;
//			//xmov -4; drop; //drop;
//			
//			goto ^EONode;
//			//here;
//			
//		:LocalIdentifier;
//			//drop;
//			//here;
//			
//			get-node-value;// xmovup;
//			get-variable;
//			get-variable-value;
//			goto ^EONode;
////		Identifier,
////			Instruction,
////			InputIdentifier,
////			OutputIdentifier,
////			LocalIdentifier,
////			GlobalIdentifier,
////			FunctionIdentifier,
////			Word,
////
////			Type,
////			PackedTuple,
////		
//		:ArgumentBlock;
//			//here;
//			//error "Using ArgumentBlock as a first item";
//			ProcessBlock;
//			xget 4;
//			call-function;
//			//here;
//			xmov -4; drop; drop; drop;
//			
//			goto ^EONode;
//			
//		:GroupingBlock;
//			//here;
//			ProcessBlock;
//			xmovup;
//			//here;
//			goto ^EONode;
////			here;
////			Emulate_ProcessBlock;
////			here;
////			
//		:EONode;
//			//here;
//			//xset 4;
//			//drop;
//			//here;
//		//true;
//	?>;
//	ret;
//	
//	:WriteMode;
//		here;
//		
//		get-node-type;
//		case $.SyntaxNodeType.GroupingBlock ^Grou
//		
//		xget 4;
//		xget 2;
//		get-node-value;
//		set-variable;
//		//get-object-type;
//		drop;
};
ProcessAtom-Read (iNode)
{
	//here;
	
	dup;
	is-node?;
	<?;
		drop;	
		//here;
		//push $.SyntaxNodeType.NumInt31;
		get-node-type; //dup; sub 0; here;
			case $.SyntaxNodeType.NumInt32 ^NumInt32;
			case $.SyntaxNodeType.String   ^NumInt32;
			//~~case 19 ^LocalIdentifier;
			//case LocalIdentifier ^LocalIdentifier;
			case $.SyntaxNodeType.Identifier      ^Identifier;
			case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
			
			case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
			case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
			
			error "Unresolved";
		
		:NumInt32;
			//here;
			//drop;	
			get-node-value;
			
			//here;
			ret;
			
		:Identifier;
			//here;
			//~~push 0; push 5; xmov; drop;
			xmov 0 5; dup; xmov; drop;
			//here;
			get-node-value;
			get-member;
			xmovup;
			
			//dup;
			//xset "------" 2;
			//here;
			//~~push -4; xmov; drop; drop; swap;
			//xmov -4; drop; //drop;
			
			ret;
			//here;
			
		:LocalIdentifier;
			//drop;
			//here;
			
			get-node-value;// xmovup;
			get-variable;
			get-variable-value;
			ret;
//		Identifier,
//			Instruction,
//			InputIdentifier,
//			OutputIdentifier,
//			LocalIdentifier,
//			GlobalIdentifier,
//			FunctionIdentifier,
//			Word,
//
//			Type,
//			PackedTuple,
//		
		:ArgumentBlock;
			//here;
			//error "Using ArgumentBlock as a first item";
			ProcessBlock;
			xget 4;
			call-function;
			//here;
			xmov -4; drop; drop; drop;
			
			ret;
			
		:GroupingBlock;
			//here;
			ProcessBlock;
			xmovup;
			//here;
			ret;
//			here;
//			Emulate_ProcessBlock;
//			here;
//			
		//:EONode;
			//here;
			//xset 4;
			//drop;
			//here;
		//true;
	?>;
	error "ND";
};
ProcessAtom-Write (iNode)
{
	//here;
	dup;
	get-node-type;
		case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
		case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
		case $.SyntaxNodeType.Identifier      ^Identifier;
		case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
		
		error "NI";
	
	:LocalIdentifier;
		//here;
		xget 5;
		xget 2;
		get-node-value;
		set-variable;
		//get-object-type;
		drop;
		xmovup;
		ret;
		
	:Identifier;
		//here;
		//~~push 0; push 5; xmov; drop;
		xget 5;
		xget 4;
		xget 3;
		
		//xmov 0 5; dup; xmov; drop;
		//here;
		get-node-value;
		set-member;
		//here;
		xmovup;
		
		//dup;
		//xset "------" 2;
		//here;
		//~~push -4; xmov; drop; drop; swap;
		//xmov -4; drop; //drop;
		
		ret;
	:ArgumentBlock;
		//here;
		
		ProcessBlock;
		xget 6;xget 6;xget 3;xget 7;
		
		call-function;
		//here;
		xmov -7; drop;drop;drop;drop;drop;drop;
			
		ret;
	:GroupingBlock;
		//here;
		//~~ check expression count: allowed only 1 expression in block;
		node-length; equals? 1; not;
		<?;
			drop;
			error "Only 1 expression allowed";
		?>;
		drop;
		
		//~~ unflolding;
		dup; unfGB 1; drop;
		//here;
		
		//~~ check list count: allowed only 1 list in the only expression;
		node-length; equals? 1; not;
		<?;
			drop;
			error "Only 1 list allowed";
		?>;
		drop;
		
		//here;
		//~~ processing list;
		unfE 1; drop; unfL 1;
		<*;
			here;
		*>;
		
		here;
		ret;
};

//ProcessAtom-Function
//{
//	here;
//	//~~push 0; push 4; xmov; drop; push 0; compare;
//	xget 2; compare 0;
//	<?;
//		drop;
//	
//		//~~ push 0; push 5; xmov; drop;
//		xget 3; get-node-type; equals? $.SyntaxNodeType.BLAADASF;
//		<?;
//			drop;
//			
//			
//			here;
//			true;
//		?>;
//		drop;
//		here;
//		
//		ret;
//	?>;
//	drop;
//};
Emulate_ProcessBlock (iNode,oStrHW,oNum1,oNum2,oResCount)
{
	push "Hello, World!" 222 111 3;
};
MyTestFunction (iList,oList)
{
	//here;
	dup;
	unfold-list;
	<*; sub 1; xmov -3; drop; drop; *>; drop;
	
	
	fold-list "YO-HO-HO!" 222 333 444 555 5;
};

);
//(_X,_Y,_Str 111,222,"Hello, World".ToString[12345]);
//(_X,_Y,_Str 111,222,"Hello, World");
//~~(111,"Hello, World",_MyObject.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.MemA.MemB.MemC.FuncA[1,(1 + gSomething)].FuncB[_MyObj]);
//("11111","22222","33333");
//(_MyObj.MemA.MemB.MemC.FuncA,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[].AAA.BBB.CCC,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[11111,22222,33333].AAA.BBB.CCC,44444,555555);
(
	//_Node.Children[1].Children[0]  _MyChild;
	
	//_Str,_X,_Y   "Hello, World!",_MyObj.Age,_MyNum;
	////_Str,_X,_Y   "Hello, World!",_MyObj.Age,_MyNum;
	////~~_Str,_X,_Y,_Z _MyNum;
	//_X,_Y,_Str 42,12345,"Hello, World!";
	//(123,456) 123456;
	//(111,222) (333,444);
	_TEST                _MyObj.MemA.MemB.MemC.FuncA[333,444,555];
	
	_MyObj.Items[12345]  "First item";
	_X,_Y                _MyObj.Age,42;
	_X,_Y                _Y,_X;
		
	_Z           56;
	_MyObj.Age   _Z;
	_MyObj.Age;
	
	_Name1       _MyObj.MemA.MemB.MemC;
	_MyObj.MemA  2;
	_Name2       _MyObj.Name;
	
	_MyObj;
	

	
	//''

//	_List (123,456);
	
//	_X          11111;
//	_X,_Y       11111,22222;
	//_X,_Y,_Str  11111,22222,"Hello";
//	
//	_PosXY,(_W,_H) (111,222),(333,444);
//	
//	
//	_TEST _MyObj.MemA.MemB.MemC.FuncA[333,444,555];
	//42 + _MyObj.Age;
	//_MyObj.MemA.MemB.MemC.FuncA[11111,22222,"Hello, FuncA!"],11111,22222;
	//_MyObj.MemA.MemB.MemC.FuncA["Inputs1"] "Inputs2";
	//88,88,88,88,88,88,88,88,88,88,88;
	//55555555;
	//66666666;
	//77777777;
	//111,111111,111111111;
	//222,222222,222222222;
	//_MyObj.Age,333333,_MyObj.Name;
);
//(_MyObj.MemA.MemB.MemC,_MyObj.Name,_MyObj.Age,12345,"Hello, World!");
//(_MyObj.MemA.MemB.MemC.FuncA[111,222,"Hello, World!"].FuncB[_MyObj]);
//((111,222,"Hello, World!"));
//(i1 * 2);
//~~(2.718281828,"Hello, World!");
//(_X 111; _Y 222);
_X,_Y (123,iForm.Name,_MyObj.Name.Func[1,2,_Name.ToString[]],SomethingElse);


//RealNumber {Value;
//_MyRealNumber RealNumber[];

//_StringValue  $.Value.$str.Substring[0,3];
//_MyRealNumber._StringValue;

//Expression -> List -> ListItem -> Atom(inc. Block) -> Expression;
//";"          " "     ","         "."      "[,],(,),{,}"     
