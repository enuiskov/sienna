(@reset;    @<; @mode 254; @>; @hault; @<; @mode 255; @>;
//@dup;       @<; @osp++; @push 3; @mov; @osp--; @>;
//~~@dup;       @<; @mov -1; @>;
@dup;       @<; @mov -1; @>;
//@neg;       @<?; @dup; @osp--; @osp--; @push 0; @osp++; @sub; @>;
@neg;       @<; @dup; @mov 0 -4; @drop; @drop; @sub; @>;
@add;       @<; @neg; @sub; @>;
@inc;       @<; @sub -1; @>;
@dec;       @<; @sub +1; @>;
@sign;      @<; @jpos ^POS; @neg; @jpos ^NEG; @ret; @:POS; @ret +1; @:NEG; @ret -1; @>;
@compare;   @<; @sub; @sign; @>;
@swap_n;    @<; @dup; @dup; @sub -2; @mov; @dup; @mov 6; @mov 4; @drop; @neg; @sub 2; @mov; @drop; @drop; @drop; @mov -4; @drop; @drop; @>;
@swap;      @<; @swap_n 3; @drop; @>;

@get;       @<; @dup; @sub -2; @mov; @drop; @>;
//~~@set;       @<; @neg; @sub +2; @mov; @drop; @drop; @>;
@set;       @<; @neg; @sub +1; @mov; @drop; @drop; @>;
@movup;     @<; @mov -3; @drop; @drop; @>;
@true;      @<; @ret 1; @>;
@false;     @<; @ret 0; @>;
@not;       @<; @jpos ^1; @neg; @jpos ^1; @drop; @ret 1; @:1; @ret 0; @>;
@make12345; @<; @push N-111 N-2222 N-33333 N-444444 N-5555555; @>;
@goto;      @<; @dup; @set 1 3; @csp--; @jpos; @>;
//@is-zero?; @<; @not; @>;
@case;      @<; @get 3; @get 3; @sub; @not; @jpos ^Jumping; @drop;@drop;@drop; @ret; @:Jumping; @mov -3; @set 1 5; @drop; @drop; @csp--; @jpos; @>;
//@jump;      @<; @push 1; @swap; @csp--; @jpos; @>;
//@jif0;      @<; @swap; @dup; @push ^POS; @jpos; @neg; @push ^NEG; @jpos; @osp--; @osp--; @csp--; @jump; @:POS; @:NEG; @swap; @drop; @>;
//@jifeq;
//@<;
//	//@here;
//	@dup; @mov 5; @mov 5; @osp--; @compare; @push ^IfJumping; 
//	@jif0;
//	
//	@osp--;@osp--;@ret;
//	
//	@:IfJumping; @mov -4; @osp--;@osp--;@osp--; @csp--; @jump;
//@>;
//@jif1;      @<; @here; @swap; @dup; @push 1; @sub; @push ^IFJUMPING; @jif0; @osp--; @push -3; @mov; @osp--; @osp--; @ret; @:IFJUMPING; @osp--; @csp--; @jump; @>;
@equals?;   @<; @get 2; @get 2; @sub; @not; @set 3; @drop; @jpos ^True; @ret; @:True; @ret 1; @>;
@dignode;   @<; @unfold; @dec; @swap; @>;


@delete;    @<; @dup; @jpos ^OK; @error "WTF: non-positive offset specified"; @:OK; @dup;@dup; @<*; @sub -2; @mov; @neg; @sub 1; @mov; @neg; @sub 4; @*>; @drop; @drop; @drop; @drop; @>;
@insert;    @<; @get 2; @get 2; @<*; @push 7; @get 4; @get 3; @sub; @neg; @sub; @dup; @mov; @neg; @sub -1; @mov; @drop; @drop; @dec; @*>; @drop; @get 2; @neg; @sub 4; @mov; @drop;@drop;@drop;@>;

//@get; @<; @push 0; @push iA; @>;
//@get 5;
//@set 4;

@!program;
@<;
	@GetBaseGroupingBlock;
	//@here;
	@ProcessBlock;
	@movup;
	
	@here;
	@unfold-list;
	@drop;
	@unfold-list;
	@here;
@>;

//@CallFunction;
//@<;
//	
//@>;
@GetBaseGroupingBlock;
@<;
	@unfE 1; @drop;
	@unfL 1; @drop;
	@unfI 1; @drop;
	//@unfold; //@drop;
@>;
@ProcessBlock;
@<;
	//@here;
	@node-length; @jpos ^Children;
	@drop;@drop; @fold-list 0; @ret;
	
	@:Children;
		//@dup;
		@push "-- RETVAL --";
		//@mov "RETVALHERE" -4; @drop; @drop;
		//@here;
		@get 2;
		@unfGB 1;
		@<*;
			//@here;
			//@dec;
			@get 2;
			//@here;
			@ProcessExpression;
			//@here;
			
			//@get 2;
			//@here;
			//~~ setting return value;
			@get 4; @sub -5; @set;
			
			//@drop;
			//~~@get 3; @set 5;
			@movup;//~~@set 2;
			
			//@drop;@drop;
			//@get 2; @set 4; @set 2;
			//@dup;
			
			@jpos ^NextExpression;
			@drop;@drop;
			@<*;
				//~~ removing queue;
				@dec; @movup;
			@*>;
			@drop;@ret;
			
			@:NextExpression;
				@movup;
				//@here;
				//@drop;
				//@here;
			@dec;
		@*>;
		//@here;
		@drop;


//	@here;
//	@x-unfold-node 1;
//	
//	@dup; @jpos ^Children; //~~ empty block allowed, returns empty list;
//	@drop;
//	@fold-list; @ret;
//	
//	@:Children;
//	@<*;
//		@dec;
//		@get 2;
//		@ProcessExpression;
//		@set 3;
//	@*>;
//	@drop;
@>;
//@ProcessBlock; //~~ S0 = iNode;
//@<;
//	//@here;
//	@node-length; @jpos ^Children;
//	@drop;@drop; @fold-list 0; @ret;
//	
//	@:Children;
//		@dup;
//		@mov "RETVALHERE" -4; @drop; @drop;
//		@x-unfold-node 1;
//		@<*;
//			@here;
//			@dec;
//			@dup;@dup;
//			@sub -4;
//			@mov;
//			@drop;
//			
//			@here;
//			@ProcessExpression;
//			@here;
//			
//			//@get 2;
//			@get 2; @sub -4; @set;
//			//@drop;
//			//@set 3;
//			//@drop;
//			//@drop;@drop;
//			//@get 2; @set 4; @set 2;
//			//@dup;
//			
//			@jpos ^NextExpression;
//			@drop;
//			@<*;
//				//~~ removing queue;
//				@here;
//				@dec; @mov -3; @drop; @drop;
//			@*>;
//			
//						
//			@:NextExpression;
//				//@here;
//		@*>;
//		//@here;
//		@drop;
//		@drop;
//
//
////	@here;
////	@x-unfold-node 1;
////	
////	@dup; @jpos ^Children; //~~ empty block allowed, returns empty list;
////	@drop;
////	@fold-list; @ret;
////	
////	@:Children;
////	@<*;
////		@dec;
////		@get 2;
////		@ProcessExpression;
////		@set 3;
////	@*>;
////	@drop;
//@>;
//@ProcessBlock;
//@<;
	//@here;
	//@node-length; @jpos ^Children;
	//@drop;@drop; @fold-list 0; @ret;
	
	//@:Children;
		//@dup;
		//@mov "RETVALHERE" -4; @drop; @drop;
		//@x-unfold-node 1;
		//@<*;
			//@dec;
			//@get 2;
			//@ProcessExpression;
			////@here;
			//@get 2; @sub -4;
			//@set;
			////@drop;
			//@mov -3;
			//@drop;@drop;
		//@*>;
		////@here;
		//@drop;
	
////	@here;
////	@x-unfold-node 1;
////	
////	@dup; @jpos ^Children; //~~ empty block allowed, returns empty list;
////	@drop;
////	@fold-list; @ret;
////	
////	@:Children;
////	@<*;
////		@dec;
////		@get 2;
////		@ProcessExpression;
////		@set 3;
////	@*>;
////	@drop;
//@>;
@ProcessExpression; //~~ S0=iExpNode -> S0=oExpList,S1=oDoProceedNext;
@<;
	//@here;
	//@drop;
//	@push 1;
//	@fold-list 11 22 33 3;
//	
//	@ret;

	
	
	@get-node-role;
		@case $.SemanticRole.ExpOneList    ^OneList;
		@case $.SemanticRole.ExpAssignment ^Assignment;
		@case $.SemanticRole.ExpCustom     ^Custom;
		@case $.SemanticRole.Unknown        ^Assignment;
		@error "Not implemented";
	@drop;
	
	
	
	@:OneList;
		//@here;
		@ProcessExpression-OneList;
		@ret;
	@:Assignment;
		//@here;
		@ProcessExpression-Assignment;
		//@here;
		@ret;
	@:Custom;
		@here;
		@ret;
@>;
@ProcessExpression-OneList;
@<;
	//@here;
	@push "NOTHINGTOWRITE";
	@push 0; //~~ is write mode?;
	@get 3;
	@unfE 1; @drop;
	@ProcessList;
	//@here;
	
	@movup;
	
	@set 1 4; //~~ do proceed next expression;
	@movup;
	//@true;
	
	
	//@here;
	//@drop;
	//@push 1;
	//@fold-list 111 222 333 3;
@>;
//@ProcessExpression-OneList;
//@<;
//	@here;
//	@x-unfold-node 1;
//	
//	@dup; @jpos ^Children; //~~ any expression returns list;
//	@drop;
//	@fold-list; @ret 0;
//	
//	
//	@:Children;
//	@<*;
//		@dec;
//		@get 2;
//		@here;
//		@ProcessList 0; //~~ is writemode?;
//		@here;
//		@set 3;
//		@drop;
//	@*>;
//	@drop;
//	@ret 1;
//@>;
@ProcessExpression-Assignment;
@<;
	//@here;
	@dup;
	@unfE 1;
	
	@drop;
	//@here;
	//~~ processing source list;
	@push "NOTHINGTOWRITE";
	@push 0; @get 4; @ProcessList; @movup; @movup; @movup; //@here;
	@unfold-list;
	
		
	@dup; @sub -2; @get;
	@unfL 1;
	
	//~~ determining the type of assignment: list-to-list, folding and unfolding a tuple;
	@dup; @sub -2; @get;
	@mov 0 4; @drop;
	//@here;
	//~~ S0 and S1 are the list lengths;
	@sub;
	@not; @jpos ^ListToList; @error "Tuples are not implemented yet";
	
	
	@:ListToList;
		@dup;
		//@here;
		@<*;
			//@here;
			//~~ computing zero-based offset to grow;
			@push 3; @get 2; @sub; //@neg;
			
			//@here;
			//~~ list item to read;
			@get 3; @dup; @neg; @sub; @sub -4; //~~ count+count+3;
			@get 2; @neg; @sub; @dup; //~~ adding zero-based offset;
			@mov; @drop;
			
			
			@push 1; //~~ the 'write-mode' argument;
			
			//@here;
			//~~ list item to write
			@get 5; @get 5; @sub; @sub -6; @get;
			
			//@here;
			@ProcessListItem;
			//@here;
			
			@drop;@drop;@drop;@drop;@drop;
			
//			@get-node-value;// @movup;
//			@get-variable;
//			
//			@here;
//			@set-variable;
//			
//			
			@dec;
		@*>;
	
		//~~@dup; @sub -2; @get;
		//@here;
		@drop;
		@<*; @dec; @movup; @*>; @drop;
		//@here;
		@fold-list;
		@set 1 4;
		@movup;
		
		//@here;
		//@<*; @dec; @movup; @*>; @drop;
		//@drop;
		//@drop;
@>;
@ProcessList; //~~ S0=iNode,S1=iIsWriteMode,S2=VALUETOWRITE_NOT_USED -> S0=oList
@<;
	
	//@drop;//@drop;
//	@fold-list 1111 2222 3333 3;
//	@ret;

	//@here;
	@dup; @unfL 1;
	@dup;
	@<*;
		//@here;
		@push "------";
		
		//@here;
		//~~ node;
		@get 3; @get 3; @sub; @sub -5; @mov;// @drop;
		//@here;
		//~~ optional value to write;
		//@here;
		@get 4; @sub -9; @dup; @mov;
		//@get 10;
		//@dup; @sub -5; @get;
		
		//@here;
		//~~ write-mode flag;
		@dup; @mov; @drop;//@get 10;
		//@get 2; @sub -5; @get;
		
		//~~@<?; @here; @?>;
		
		@get 4;
		//@here;
		@ProcessListItem;
		//@here;
		
		@mov -7;  @drop; @drop; @drop; @drop; @drop;
		@neg;
		@mov;     @drop; @drop;
		
		@dec;
		//@here;
	@*>;
	//@here;
	@drop;
	@fold-list; //~~ expects [Count,Item1,Item2, .. ItemN];
	//@mov -4; @drop; @drop; @drop;
@>;
//@ProcessList;
//@<;
//	//@here;
//	
//	
//	@unfold 1;
//	@<*;
//		//@stacksize; @sub 14; @<?; @here; @?>; @drop;
//		@dec;
//		@get 2;
//		@here;
//		@ProcessListItem;
//		@set 3;
//	@*>;
//	@drop;
//	
//	@here;
//	@fold-list; //~~ expects [Count,Item1,Item2, .. ItemN];
//@>;
@ProcessListItem; //~~ S0=iNode,S1=iIsWriteMode,S2=iValueToWrite(opt); -> S0=oList(opt);
@<;
	//@get 2; @<?; @here; @?>; @drop;
	
//	@fold-list 111 2222 3333 3;
//	
//	@ret;
	
	//@here;
	//@get 2;
	//@drop;
	//~~ can return folded list;
	@push "-- MEMBERBASE --";
	@get 2;
	
	@unfI 1;//@here;
	@<*;
		//@here;
		@dup;
		//~~ if is last atom in list-item (uses write-mode flag);
		@equals? 1; @<?; @mov 7; @drop; @?>;
		
		//@drop; 0 - [iIsWriteMode = 0];
		//@dup;
		//~~ value-to-write;
		@get 2; @sub -6; @get;
		//~~  write-mode flag;
		@get 2;
		//~~ member base;
		@get 4; @sub -5; @get;
		
		//@here;
		///@get 4; @<?; @here; @?>; @drop;
		@get 6;
		//@here;
		@ProcessAtom;
		
		//@here;
		//@get 4; @<?; @here; @?>; @drop;
		//@here;
		
		@get 7; @sub -8; @set;
		@drop; @drop; @drop; @drop; @drop;
		@movup;
		@dec;
	@*>;
	//@here;
	@drop;
	//@set 3; @drop;
@>;
//~~@ProcessListItem;
//@<;
//	@drop;
//	//~~ can return folded list;
//	@x-unfold-node 1;
//	
//	@<*;
//		@get 2;
//		@ProcessAtom 0;
//		@dec;
//	@*>;
//	@drop;
//	
//@>;
@ProcessAtom;  //~~ S0=iNode,S1=iMemberBase,S2=iIsWriteMode,S3=iValueToWrite(opt); -> S3=oValue(opt)
@<;
	//~~@get 3; @<?; @here; @?>; @drop;
	//@here;
	//@ret "ATOM";
	
	
	@get 3; @jpos ^WriteMode; @drop;
	
	
	//@here;
	//@error "NI";
	//@drop;
	@dup;
	@is-node?;
	@<?;
		@drop;	
		//@here;
		//@push $.SyntaxNodeType.NumInt31;
		@get-node-type; //@dup; @sub 0; @here;
			@case $.SyntaxNodeType.NumInt32 ^NumInt32;
			@case $.SyntaxNodeType.String   ^NumInt32;
			//~~@case 19 ^LocalIdentifier;
			//@case LocalIdentifier ^LocalIdentifier;
			@case $.SyntaxNodeType.Identifier      ^Identifier;
			@case $.SyntaxNodeType.LocalIdentifier ^LocalIdentifier;
			
			@case $.SyntaxNodeType.ArgumentBlock   ^ArgumentBlock;
			@case $.SyntaxNodeType.GroupingBlock   ^GroupingBlock;
			
			@error "Unresolved";
		
		@:NumInt32;
			//@here;
			//@drop;	
			@get-node-value;
			
			//@here;
			@goto ^EONode;
			
		@:Identifier;
			//@here;
			//~~@push 0; @push 5; @mov; @drop;
			@mov 0 5; @dup; @mov; @drop;
			//@here;
			@get-node-value;
			@get-member;
			@movup;
			
			//@dup;
			//@set "------" 2;
			//@here;
			//~~@push -4; @mov; @drop; @drop; @swap;
			//@mov -4; @drop; //@drop;
			
			@goto ^EONode;
			//@here;
			
		@:LocalIdentifier;
			//@drop;
			//@here;
			
			@get-node-value;// @movup;
			@get-variable;
			@get-variable-value;
			@goto ^EONode;
//		Identifier,
//			Instruction,
//			InputIdentifier,
//			OutputIdentifier,
//			LocalIdentifier,
//			GlobalIdentifier,
//			FunctionIdentifier,
//			Word,
//
//			Type,
//			PackedTuple,
//		
		@:ArgumentBlock;
			//@here;
			//@error "Using ArgumentBlock as a first item";
			@ProcessBlock;
			@get 4;
			@call-function;
			//@here;
			@mov -4; @drop; @drop; @drop;
			
			@goto ^EONode;
			
		@:GroupingBlock;
			//@here;
			@ProcessBlock;
			@movup;
			//@here;
			@goto ^EONode;
//			@here;
//			@Emulate_ProcessBlock;
//			@here;
//			
		@:EONode;
			//@here;
			//@set 4;
			//@drop;
			//@here;
		//@true;
	@?>;
	@ret;
	
	@:WriteMode;
		//@here;
		@get 4;
		@get 2;
		@get-node-value;
		@set-variable;
		//@get-object-type;
		@drop;
@>;
@ProcessAtom-Function;
@<;
	//~~@push 0; @push 4; @mov; @drop; @push 0; @compare;
	@get 2; @compare 0;
	@<?;
		@drop;
	
		//~~ @push 0; @push 5; @mov; @drop;
		@get 3; @get-node-type; @equals? $.SyntaxNodeType.BLAADASF;
		@<?;
			@drop;
			
			
			@here;
			@true;
		@?>;
		@drop;
		@here;
		
		@ret;
	@?>;
	@drop;
@>;
@Emulate_ProcessBlock;
@<;
	@push "Hello, World!" 222 111 3;
@>;
@MyTestFunction;
@<;
	//@here;
	@dup;
	@unfold-list;
	@<*; @sub 1; @mov -3; @drop; @drop; @*>; @drop;
	
	
	@fold-list "YO-HO-HO!" 222 333 444 555 5;
@>;

);
//(_X,_Y,_Str 111,222,"Hello, World".ToString[12345]);
//(_X,_Y,_Str 111,222,"Hello, World");
//~~(111,"Hello, World",_MyObject.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.Name.Substring[1,(1 + gSomething)]);
//(_MyObj.MemA.MemB.MemC.FuncA[1,(1 + gSomething)].FuncB[_MyObj]);
//("11111","22222","33333");
//(_MyObj.MemA.MemB.MemC.FuncA,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[].AAA.BBB.CCC,44444,555555);
//(_MyObj.MemA.MemB.MemC.FuncA[11111,22222,33333].AAA.BBB.CCC,44444,555555);
(
	//_Node.Children[1].Children[0]  _MyChild;
	
	//_Str,_X,_Y   "Hello, World!",_MyObj.Age,_MyNum;
	////_Str,_X,_Y   "Hello, World!",_MyObj.Age,_MyNum;
	////~~_Str,_X,_Y,_Z _MyNum;
	//_X,_Y,_Str 42,12345,"Hello, World!";
	//(123,456) 123456;
	//(111,222),(333,444);

//	_List (123,456);
	
//	_X          11111;
//	_X,_Y       11111,22222;
	_X,_Y,_Str  11111,22222,"Hello";
//	
//	_PosXY,(_W,_H) (111,222),(333,444);
//	
//	
//	_TEST _MyObj.MemA.MemB.MemC.FuncA[333,444,555];
	//42 + _MyObj.Age;
	//_MyObj.MemA.MemB.MemC.FuncA[11111,22222,"Hello, FuncA!"],11111,22222;
	//_MyObj.MemA.MemB.MemC.FuncA["Inputs1"] "Inputs2";
	//88,88,88,88,88,88,88,88,88,88,88;
	//55555555;
	//66666666;
	//77777777;
	111,111111,111111111;
	//222,222222,222222222;
	//_MyObj.Age,333333,_MyObj.Name;
);
//(_MyObj.MemA.MemB.MemC,_MyObj.Name,_MyObj.Age,12345,"Hello, World!");
//(_MyObj.MemA.MemB.MemC.FuncA[111,222,"Hello, World!"].FuncB[_MyObj]);
//((111,222,"Hello, World!"));
//(i1 * 2);
//~~(2.718281828,"Hello, World!");
//(_X 111; _Y 222);
_X,_Y (123,iForm.Name,_MyObj.Name.Func[1,2,_Name.ToString[]],SomethingElse);
















































































