//~~(1;;); //~~ forces syntax error after double ';';
(
*!1 {get_SP};
*!2 {sub get_SP,-1};
*!3 {sub get_SP,-2};
*!4 {sub get_SP,-3};
*!5 {sub get_SP,-4};
*!6 {sub get_SP,-5};
*!7 {sub get_SP,-6};
*!8 {sub get_SP,-7};
*!9 {sub get_SP,-8};

*drop  {drop1};
*drop1 {set_SP (sub get_SP,-1)};
*drop2 {set_SP (sub get_SP,-2)};
*drop3 {set_SP (sub get_SP,-3)};
*drop4 {set_SP (sub get_SP,-4)};
*drop5 {set_SP (sub get_SP,-5)};
*drop6 {set_SP (sub get_SP,-6)};
*drop7 {set_SP (sub get_SP,-7)};
*drop8 {set_SP (sub get_SP,-8)};
*drop9 {set_SP (sub get_SP,-9)};

*push  {};
*bla   {nop};
*dup   {get !1};
*movup {set !2};

//*!0 {sub get_SP,+1};
*j<=0 {csp++; jlez};

reset  {mode 254};

*add   {neg; sub};
*neg   {dup; set !3 0; sub};

*mulsign
{
//	+60,0; //~~ +1;
//	+60,0; //~~ -1;
//	-60,+1; //~~ -1;
//	-60,-1; //~~ +1;
//	
	//!!!;
	dup;
	jpos not,^Z;
		jpos drop,^P;
			drop; neg;
		:P;
		//!!!;
		ret;
		//~~goto ^RET;
	
	:Z;
	//!!!;
	drop2; 0;
	
	//~~:RET;
	//	!!!;
};

mul   (iOp1,iOp2,oV,_Neg2,cI)
{
	//!!!;
//	get,sign iOp1;
//	get,sign iOp2;
//	
	jpos (sub (get iOp2; get iOp1)),^DontSwap;
	(
		drop;
		get iOp1;
		set iOp1 (get iOp2);
		set iOp2;
	);
	:DontSwap;
	
	
	//!!!;
	set oV 0;
	set _Neg2 (get,neg iOp2);
	
	set cI (get,abs iOp1); :I; jpos,drop (dec,dup),^I
	(
		//!!!;
		set oV (sub (get oV; get _Neg2));
	);
	//!!!;
	set oV (mulsign (get oV; get,sign iOp1));
};

*abs     {dup; jpos ^RET; drop; neg; :RET;};
*sign    {jpos ^POS; neg; jpos ^NEG; ret; :POS; ret +1; :NEG; ret -1; };
*clamp01 {sign; inc; dup; jpos ^GE0; drop; ret; :GE0; dec};

*goto    {csp++; set_IP};

*case    {jpos (not sub (get !3; get !2)),^J; drop3; ret; :J; drop; movup; csp++; set_IP};
*not     {jpos ^1; neg; jpos ^1; drop; ret 1; :1; ret 0};
*and     {sub (clamp01,neg; set !3 (get,clamp01 !2)); dec; clamp01};
*or      {!!!; };
*xor     {!!!; };

//*case
//{
//	xget 3; xget 3; sub; not;
//	
//	jpos ^Jumping; drop;drop;drop; ret; :Jumping; xmov -3; xset 1 5;
//	drop; drop; csp--; jpos;
//};
*loop {dup};

*inc {sub -1};
*dec {sub +1};

**inc {dup; dup; get; inc; set !3; set};
**dec {dup; dup; get; dec; set !3; set};

**sub    {!!!;};
**equals {!!!;};
**less?  {get; !3; get; sub; jpos ^TRUE; set !3 0; drop; ret; :TRUE; set !2 1;};

test (_L1,_L2)
{
	set _L1 4;
	set _L2 5;
	
	*less? _L1,_L2;
	!!!;
	
};
*white {255,255,255,255};
*black {255,0,0,0};
*red   {255,255,0,0};
*green {255,0,255,0};
*blue  {255,0,0,255};

*yellow {255,255,255,0};


*rgba
{
//	set 2;
//	set 1;
//	set 0;
//	set 3;

	//!!!;
	mul 4;
	//!!!;
	//drop;
	//~~ drop seq: 2,1,0,3;
	//!!!;
	set (get !4; get !2); inc;
	set (get !3; get !2); inc;
	set (get !2; get !2); inc;
	set (get !5; get !2); drop5;
	//set (sub1);
	//set 0;
	//set 3;
};
//fillsquare(iA,iR,iG,iB,iX,iY,iW,iH,iScrW,iScrH,_MaxX,_MaxY,_ScanW)
//{
//	//!!!;
//	set _MaxX  (add (get iX; get iW));
//	set _MaxY  (add (get iY; get iH));
//	set _ScanW (mul (get iScrW; 1));
//	
//	dup get iY; :NextRow; jpos (sub (get _MaxY; get !2)),^NextRow
//	(
//		dup get iX; :NextCell; jpos (sub (get _MaxX; get !2)),^NextCell
//		(
//			add (mul (get _ScanW; get !4));
//			
//			rgba (get !5) (get iA;get iR;get iG;get iB);
//			drop;
//			
//			
//			inc;
//			dup;
//			//!!!;
//		);
//		drop3;
//		//!!!;
//		inc;
//		dup;
//	);
//	!!!;
//};
*screensize {30,20};
fillsquare(iA,iR,iG,iB,iX,iY,iW,iH,iScrW,iScrH,_MaxX,_MaxY,_ScanW,cX,cY,cBase)
{
	set _MaxX  (add (get iX; get iW));
	set _MaxY  (add (get iY; get iH));
	set _ScanW (mul (get iScrW; 1));
	
	set cY (get iY); :Y; jpos,drop (sub (get _MaxY; get cY)),^Y
	(
		set cX (get iX); :X; jpos,drop (sub (get _MaxX; get cX)),^X
		(
			set cBase (mul (get _ScanW; get cY); add (get cX));
			rgba (get cBase) (get iA;get iR;get iG;get iB);
			
			*inc cX;
			//!!!;
		);
		*inc cY;
		!!!;
	);
	//!!!;
};
drawimage
{
//	mul 0,5; !!!; drop;
//	mul -5,60; !!!; drop;
//	mul 3,5; !!!; drop;
//	mul 20,30; !!!; drop;
////	
//	mul 10,-12; !!!; drop;
	
	//!!!;
	
	
	//rgba 0 white;
	//rgba 1 black;
	//rgba 2 white;
	//rgba 3 black;
	//rgba 4 red;
	//rgba 5 green;
	//rgba 6 blue;
	//!!!;
	//afsf;

	fillsquare (white, 0,0,30,20,screensize);
	fillsquare (black, 1,1,28,18,screensize);
	fillsquare (white, 2,2,26,16,screensize);
	
	fillsquare (red,   6,3,10,8,screensize);
	fillsquare (green, 10,6,10,8,screensize);
	fillsquare (blue,  4,7,20,3,screensize);
	
	fillsquare (white, 2,2,26,16,screensize);
	fillsquare (red,   7,4,10,8,screensize);
	fillsquare (green, 11,7,10,8,screensize);
	fillsquare (blue,  5,8,20,3,screensize);
	
	fillsquare (white, 2,2,26,16,screensize);
	fillsquare (red,   8,5,10,8,screensize);
	fillsquare (green, 12,8,10,8,screensize);
	fillsquare (blue,  6,9,20,3,screensize);
	
	fillsquare (white, 2,2,26,16,screensize);
	fillsquare (red,   9,6,10,8,screensize);
	fillsquare (green, 13,9,10,8,screensize);
	fillsquare (blue,  7,10,20,3,screensize);
	
	fillsquare (white, 2,2,26,16,screensize);
	fillsquare (black,  2,2,26,16,screensize);
	fillsquare (yellow, 1,1,28,18,screensize);
	fillsquare (black,  0,0,30,20,screensize);
	
	
	
	reset;
	!!!;
};
*adrmode {set-address-mode};
*opdmode {set-operand-mode};
*@sin {set_ident_name};


!program (oError)
{
	//test1;


	//drawimage;
	//!!!;
	//test1;
	//get 0;
	//test;
	//!!!;
	+GetBaseGroupingBlock;
	+ProcessBlock;
	
	!!!;
	reset;
};

*+GetBaseGroupingBlock
{
	get !3;
	get-node-child 0;
	get-node-child 0;
	get-node-child 0;
	set !4;
	drop2;
};
+ProcessBlock (iNode,oList)
{
	push get-node-children-count (get iNode);
	push 0;
	//!!!;
	:NextExpression;
		//!!!;
		+ProcessExpression (get-node-child (get !3),(get !2));
		
		set oList (get !2; dup; set-return-value);
		
		jpos ^DoProceedNext;
			//!!!;
			goto ^RET;
		
		:DoProceedNext;
			drop2;
			jpos (inc; sub (get !2; get !2)),^NextExpression;
		
	//!!!;
	:RET;
		//!!!;
		bla;bla;bla;
};
+ProcessExpression (iExpNode,oList,oDoProceedNext)//~~ S0=iExpNode -> S0=oExpList,S1=oDoProceedNext;
{
	set oDoProceedNext 0;

	get-node-role (get iExpNode);
	(
		case $'SemanticRole'ExpOneList    ^OneList;
		case $'SemanticRole'ExpAssignment ^Assignment;
		case $'SemanticRole'ExpCustom     ^Custom;
		case $'SemanticRole'Unknown       ^Assignment;
		
		error "Not implemented";
		!!!;
		drop;
	);
	:OneList;
		+ProcessExpression-OneList;
		set oDoProceedNext;
		set oList;
		
		goto ^RET;
		//ret;
	:Assignment;
		set oList +ProcessExpression-Assignment;
		set oDoProceedNext 1;
		
		goto ^RET;
	:Custom;
		!!!;
		goto ^RET;
	:RET;
};
+ProcessExpression-OneList (iExpNode,oList,oDoProceedNext)
{
	set oList +ProcessList
	(
		"-NOLISTTOWRITE";
		0;
		(get iExpNode; get-node-child 0; movup);
		//!!!;
	);
	set oDoProceedNext 1;
};
+ProcessExpression-Assignment (iExpNode,oDoProceedNext,oList,_SrcList,_DstList)
{
	//!!!;
	set _SrcList +ProcessList
	(
		"-NOLISTTOWRITE";
		0;
		(get iExpNode; get-node-child 1; movup);
	);
	set oDoProceedNext 1;
	set oList (get _SrcList);
	
	sub
	(
		set !4 get-node-children-count (get-node-child (get iExpNode; 0));
		set !5 get-node-children-count (get-node-child (get iExpNode; 1));
		drop3;
	);
	sign;
	(
		case  0 ^ListToList;
		case -1 ^FoldTuple;
		case +1 ^UnfoldTuple;
		error "WTFE";
	);
	
	!!!;
	:ListToList;
		//!!!;

		+ProcessList
		(
			(get _SrcList);
			(1);
			(get-node-child (get iExpNode; 0); movup);
		);
		goto ^RET;
	:FoldTuple;
		!!!;
		goto ^RET;
	:UnfoldTuple;
		!!!;
		goto ^RET;
	
	
	!!!;
	
	get iExpNode;
	get-child-node-count (get iExpNode);
	
	:RET;
};
+ProcessList (rListToWrite,iIsWriteMode,iNode,oList)
{
	set oList create-list (get-node-children-count (get iNode));
	
	push get-node-children-count (get iNode);
	push 0;
	:NextListItem;
		
		jpos,drop (get iIsWriteMode),^WriteMode;
		
		:ReadMode;
			+ProcessListItem (0,0,(get-node-child (get !5; get !4); movup));
			set-list-item (get oList; get !3; get !3);
			drop3;
			goto ^Continue;
			
		:WriteMode;
			+ProcessListItem
			(
				1;
				(get-list-item (get rListToWrite; get !3); movup);
				(get-node-child (get !5; get !4); movup);
			);
			drop;
			goto ^Continue;
		
		:Continue;
			jpos (inc; sub (get !2; get !2)),^NextListItem;
};
//~~ S0=iNode,S1=iIsWriteMode,S2=iValueToWrite(opt); -> S0=oList(opt);
+ProcessListItem (iIsWriteMode,iValueToWrite,iNode,oValueOrList,_MemberBase)
{
	set _MemberBase "-MEMBERBASE-";
	
	push get-node-children-count (get iNode);
	push 0;
	//!!!;
	:NextAtom;
		set _MemberBase
		(
			+ProcessAtom
			(
				(get-node-child (get iNode; get !2); movup);
				(get _MemberBase);
				(and (sub,dec,not (get !4; get !4)),(get iIsWriteMode)); //~~ is write mode;
				(get iValueToWrite);
			);
		);
		
		jpos (inc; sub (get !2; get !2)),^NextAtom;
		set oValueOrList (get _MemberBase);
		
};

+ProcessAtom (iNodeOrObj,iMemberBase,iIsWriteMode,iValueToWrite,oValue)
{
	jpos (get iIsWriteMode),^WriteMode;
		drop;
		set oValue (+ProcessAtom-Read (get iNodeOrObj),(get iMemberBase));
		goto ^RET;
	:WriteMode;
		//!!!;
		+ProcessAtom-Write (get iNodeOrObj; get iMemberBase; get iValueToWrite);
		goto ^RET;
	
	:RET;
};
+ProcessAtom-Read (iNodeOrObj,iMemberBase,oValue)
{
	get iNodeOrObj;
		jpos,drop (not is-node?),^NotANode;
	
	get-node-type; //dup; sub 0; here;
		case $'SyntaxNodeType'NumInt32 ^NumInt32;
		case $'SyntaxNodeType'String   ^NumInt32;
		//~~case 19 ^LocalIdentifier;
		//case LocalIdentifier ^LocalIdentifier;
		case $'SyntaxNodeType'MemberIdentifier ^MemberIdentifier;
		case $'SyntaxNodeType'LocalIdentifier  ^LocalIdentifier;
		
		case $'SyntaxNodeType'ArgumentBlock   ^ArgumentBlock;
		case $'SyntaxNodeType'GroupingBlock   ^GroupingBlock;
		
		error "Unresolved";
	
	:NumInt32;
		set oValue get-node-value;
		goto ^RET;
		
	:MemberIdentifier;
		set oValue
		(
			get iMemberBase;
			get !2;
			get-node-value;
			get-member;
		);
		goto ^RET;
		ret;
		//here;
		
	:LocalIdentifier;
		set oValue
		(
			get-node-value;
			get-variable;
			get-variable-value;
		);
		goto ^RET;
		
//		Identifier,
//			Instruction,
//			InputIdentifier,
//			OutputIdentifier,
//			LocalIdentifier,
//			GlobalIdentifier,
//			FunctionIdentifier,
//			Word,
//
//			Type,
//			PackedTuple,
//		
	:ArgumentBlock;
		set oValue (call-function (+ProcessBlock; get iMemberBase));
		goto ^RET;

	:GroupingBlock;
		//!!!;
		set oValue +ProcessBlock;
		goto ^RET;
		
	:NotANode;
		error "ND: atom is not a node?";
	:RET;
};
+ProcessAtom-Write (iNodeOrObj,iMemberBase,iValueToWrite)
{
	get-node-type (get iNodeOrObj);
		case $'SyntaxNodeType'GroupingBlock    ^GroupingBlock;
		case $'SyntaxNodeType'ArgumentBlock    ^ArgumentBlock;
		case $'SyntaxNodeType'MemberIdentifier ^MemberIdentifier;
		case $'SyntaxNodeType'LocalIdentifier  ^LocalIdentifier;
		
		error "NI";
	
	:LocalIdentifier;
		get iValueToWrite;
		get-node-value (get iNodeOrObj);
		set-variable;
		goto ^RET;
		
	:MemberIdentifier;
		//!!!;
		get iValueToWrite;
		get iMemberBase;
		set-member (get-node-value (get iNodeOrObj));
		
		
		//!!!;
				//get-node-value ;
		//set-member;
		goto ^RET;
		
	:ArgumentBlock;
		//!!!;
		call-function (+ProcessBlock; get iValueToWrite; get iMemberBase);
		//!!!;
		
		//xget 6;xget 6;xget 3;xget 7;
		//call-function (get);
		//xmov -7; drop;drop;drop;drop;drop;drop;
		//ret;
		goto ^RET;
		
	:GroupingBlock;
		!!!;
		//here;
		//~~ check expression count: allowed only 1 expression in block;
		node-length; equals? 1; not;
		<?;
			drop;
			error "Only 1 expression allowed";
		?>;
		drop;
		
		//~~ unflolding;
		dup; unfGB 1; drop;
		//here;
		
		//~~ check list count: allowed only 1 list in the only expression;
		node-length; equals? 1; not;
		<?;
			drop;
			error "Only 1 list allowed";
		?>;
		drop;
		
		//here;
		//~~ processing list;
		unfE 1; drop; unfL 1;
		<*;
			here;
		*>;
		
		here;
		ret;
	:RET;
};

+MyTestFunction (iArgsList,iAssignList,oList)
{
	set oList
	(
		create-list 4;
		set-list-item 0,  "YO-HO-HO";
		set-list-item inc,"FUCK";
		set-list-item inc,"ITWORKS";
		set-list-item inc,"AMAZING";
		drop;
	);
	//!!!;
};
);
//(_X,_Y,_Str 111,222,"Hello, World"'ToString[12345]);
//(_X,_Y,_Str 111,222,"Hello, World");
//~~(111,"Hello, World",_MyObject'Name'Substring[1,(1 + gSomething)]);
//(_MyObj'Name'Substring[1,(1 + gSomething)]);
//(_MyObj'MemA'MemB'MemC'FuncA[1,(1 + gSomething)]'FuncB[_MyObj]);
//("11111","22222","33333");
//(_MyObj'MemA'MemB'MemC'FuncA,44444,555555);
//(_MyObj'MemA'MemB'MemC'FuncA[]'AAA'BBB'CCC,44444,555555);
//(_MyObj'MemA'MemB'MemC'FuncA[11111,22222,33333]'AAA'BBB'CCC,44444,555555);
(
	//_Node'Children[1]'Children[0]  _MyChild;
	
	_MyObj'Items[111],_MyObj'Items[222],_MyObj'Items[333] "1st item","2nd item","3rd item";
	
	_MyObj'MemA'MemB'MemC'FuncA;
	

	42,"Hello, World!",_MyObj'Name,_MyObj'Age;
	111,222,333;
	444,555,666;
	777,888,999;

	//_T                _MyObj'Age,42;
	//_X,_Y                _MyObj'Name;
	_X,_Y                _MyObj'Age,42;
	

	_MyNum,42,_MyObj'Age;
	//_Str,_X,_Y   "Hello, World!",_MyObj'Age,_MyNum;
	////_Str,_X,_Y   "Hello, World!",_MyObj'Age,_MyNum;
	////~~_Str,_X,_Y,_Z _MyNum;
	//_X,_Y,_Str 42,12345,"Hello, World!";
	//(123,456) 123456;
	//(111,222) (333,444);
	
	_TEST                _MyObj'MemA'MemB'MemC'FuncA[333,444,555];
	
	_MyObj'Items[12345]  "First item";
	_X,_Y                _MyObj'Age,42;
	_X,_Y                _Y,_X;
		
	_Z           56;
	_MyObj'Age   _Z;
	_MyObj'Age2  222;
	
	_W           _MyObj'Age;
	_V           _MyObj'Age2;
	
	_Name1       _MyObj'MemA'MemB'MemC;
	_MyObj'MemA  2;
	_Name2       _MyObj'Name;
	
	_MyObj;
	

	
	//''

//	_List (123,456);
	
//	_X          11111;
//	_X,_Y       11111,22222;
	//_X,_Y,_Str  11111,22222,"Hello";
//	
//	_PosXY,(_W,_H) (111,222),(333,444);
//	
//	
//	_TEST _MyObj'MemA'MemB'MemC'FuncA[333,444,555];
	//42 + _MyObj'Age;
	//_MyObj'MemA'MemB'MemC'FuncA[11111,22222,"Hello, FuncA!"],11111,22222;
	//_MyObj'MemA'MemB'MemC'FuncA["Inputs1"] "Inputs2";
	//88,88,88,88,88,88,88,88,88,88,88;
	//55555555;
	//66666666;
	//77777777;
	//111,111111,111111111;
	//222,222222,222222222;
	//_MyObj'Age,333333,_MyObj'Name;
);
//(_MyObj'MemA'MemB'MemC,_MyObj'Name,_MyObj'Age,12345,"Hello, World!");
//(_MyObj'MemA'MemB'MemC'FuncA[111,222,"Hello, World!"]'FuncB[_MyObj]);
//((111,222,"Hello, World!"));
//(i1 * 2);
//~~(2'718281828,"Hello, World!");
//(_X 111; _Y 222);
_X,_Y (123,iForm'Name,_MyObj'Name'Func[1,2,_Name'ToString[]],SomethingElse);


//RealNumber {Value;
//_MyRealNumber RealNumber[];

//_StringValue  $'Value'$str'Substring[0,3];
//_MyRealNumber'_StringValue;

//Expression -> List -> ListItem -> Atom(inc' Block) -> Expression;
//";"          " "     ","         "'"      "[,],(,),{,}"     



	get (sub #EAX -3);

	mov EAX,ST0;
	mov eax,st0;
	mov eax,O[ebp * 2 + 4];

	mov EAX,ST0;
	mov R0,ST0;
	mov r0,st0;


	mov #EAX,#ST0;
	mov #eax,#st0;
	mov #eax,O[#ebp * 2 + 4];

	mov #EAX,#ST0;
	mov #R0,#ST0;
	

	mov @EAX,@ST0;
	mov @eax,@st0;
	mov @eax,O[@ebp * 2 + 4];

	mov @EAX,@ST0;
	mov @R0,@ST0;


	mov %EAX,%ST0;
	mov %eax,%st0;
	mov %eax,O[%ebp * 2 + 4];

	mov %EAX,%ST0;
	mov %R0,%ST0;


	mov &EAX,&ST0;
	mov &eax,&st0;
	mov &eax,O[&ebp * 2 + 4];

	mov &EAX,&ST0;
	mov &R0,&ST0;


	mov *EAX,*ST0;
	mov *eax,*st0;
	mov *eax,O[*ebp * 2 + 4];

	mov *EAX,*ST0;
	mov *R0,*ST0;

	

	set oDest;

	get @IP;
	get iOffs;
	sub;
	get;
	set oDest;


a1; aName;
b1; bName;
c1; cName;
d1; dName;
e1; eName;
f1; fName;
g1; gName;
h1; hName;
i1; iName;
j1; jName;
k1; kName;
l1; lName;
m1; mName;
n1; nName;
o1; oName;
p1; pName;
q1; qName;
r1; rName;
s1; sName;
t1; tName;
u1; uName;
v1; vName;
w1; wName;
x1; xName;
y1; yName;
z1; zName;

!1; !Name;
@1; @Name;
#1; #Name;
$1; $Name;
%1; %Name;
^1; ^Name;
&1; &Name;
*1; *Name;
'1; 'Name;
:1; :Name;
/1; /Name;
|1; |Name;
=1; =Name;
+1; +Name;
-1; -Name;
_1; _Name;
\1; \Name;
`1; `Name;
<1; <Name;
>1; >Name;
?1; ?Name;


*basic_opcodes
{
	"
		[Opc' Im7']
		[Opc' ''''][Im8''''']
		[Opc' ''''][Im16''''''''''''']
		[Opc' ''''][Im32''''''''''''''''''''''''''''']
		[Opc' ''''][Im64''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''']
	";

	0xxxxxxx; //~~ 7bit immed;
	1xxxxxxx; //~~ ;

	00000000; //~~ breakpoint;
	1xxxxxxx; //~~ push immediate 7-bit (signed?);
	01000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;
	00000000; //~~ ;



	0000  //~~basic internal opcodes;
	0001 ??
	0010 push
	0011 -drop (get_SP+push+sub+set_SP)
	0100 get
	0101 set
	0110 sub
	0111 jpos
	jlez



	1000 //~~ extended internal opcodes;
	1001 get_SP ??? registers will be mapped to memory! need revise address space/
	1010 set_SP
	1011 get_FP
	1100 set_FP
	1101 get_IP
	1110 set_IP
	1111 //~~ extended syllable (extended to byte);

	1111 0000;
	
	//drop;
	push;
	get;
	set;
	sub;
	jpos;
	(closer);
	EXT++;


	
	nop;
	ret;

	!!!;
	call;//~~ ???;
	mode,error; //~~???;
	
	opener,closer;

};

loop 10;
{
	loop 10;
	{
		bla;bla;bla;
		dec;
	};
	bla;bla;bla;
	dec;
};
!!!;

test1
{
	!!!;
	
	#b010101010;
	#1e10;
	//#
	42.0'34'123'1110001;
	10001100'01110001'10011200'11001111;
	120001202'12112;
	4'237'101'332;
	
	
	
	
	NUMBER LITERALS:
	- signed/unsigned (integers only);
			1, +1, -1
			#1,#+1,#+42,#-4,#1,#42
			#+1,#-2,#+0,
			#+42x10, #+12012x3

			+1 - +2
			(_MyNum - +2 + +3)
			128u;
			+/-/u;
			u128;
			u128t3;

	- length (byte,word etc, single/double precision);
		0.0f, 0.0d
			#42,##42,####42,
			x1,x2,x4,x8,x16

	- integer/floating-point (precision?)
		0, 0.0;
		0.0x1, 0.0x2, 0.0x4, 0.0x8;
		
			
	- numeral system;
		0, 0xff,   ->
			#10x42, #16xff, #3x121210, #2x11100011
			#42x10, #ffx16, #120120x3, #1100110x2
			#42*10, #ff*16, #120120*3, #1100110*2
			42t,
			+ff.ffffh;

			11b = 4d;
			12t = 5d;
			42n3
			+42.123e100n3

			10111010b1




	- overall;
		+42; +42*10; +42.0*10x10;
		+42; +42*10; +42.0*10x10;
		42.0_4
		42.0d_4

		


	byte,word,dword,qword;
	



	0xff000000;
	0n30;
	0d100;
	0b100111100;
	0d3'1415;
	
	#3'1415;
	
	#1 + #2;
	
	
	
	010110001b;
	122100201t;
	231532534n;
	321124124d;
	//f32355h;
	
	0'4444444n;
	
	
	
	
	
	rgba 255,0,255,0;
	
	
	
	111,222,333,"Hello, World!";
	
	//set-stack-item-type !2 $'StackItemType'Int32;
	//!!!;
	@sin  "HW_Str" 2;
	//#sit !2 "NAME";
	
	
	!!!;
	//set-binary-mode
	//0001b,2,;
	
};